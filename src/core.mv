// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/core/core.mv
// description: Core stdlib with OOP design - String, Int, Float, Array, Bytes
//
// This module provides core types with methods implemented using impl blocks.
// All functions are implemented in pure ManV using compiler intrinsics and
// syscalls - no assembly files required.
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Syscall numbers for Linux x86-64
int SYS_READ = 0;
int SYS_WRITE = 1;
int SYS_OPEN = 2;
int SYS_CLOSE = 3;
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;
int SYS_EXIT = 60;

// Memory protection flags
int PROT_READ = 1;
int PROT_WRITE = 2;

// Memory mapping flags
int MAP_PRIVATE = 2;
int MAP_ANONYMOUS = 32;

// File descriptors
int STDIN = 0;
int STDOUT = 1;
int STDERR = 2;

// Integer limits
int INT_MIN = -9223372036854775808;
int INT_MAX = 9223372036854775807;

// Error handling
int ERRNO;

// =============================================================================
// Option Type
// =============================================================================

struct Option<T> {
    has_value: bool;
    value: T;
}

impl Option<T> {
    constructor(value: T) {
        self.has_value = true;
        self.value = value;
    }
    
    fn none() -> Option<T> {
        return Option<T>{ has_value: false, value: 0 };
    }
    
    fn is_some(self) -> bool {
        return self.has_value;
    }
    
    fn is_none(self) -> bool {
        return !self.has_value;
    }
    
    fn unwrap(self) -> T {
        return self.value;
    }
    
    fn unwrap_or(self, default: T) -> T {
        if (self.has_value) {
            return self.value;
        }
        return default;
    }
}

// =============================================================================
// String Type with OOP Methods
// =============================================================================

struct String {
    data: str*;
    length: int;
}

impl String {
    // Constructor from string literal
    constructor(s: str*) {
        self.data = s;
        self.length = String._raw_len(s);
    }
    
    // Create empty string
    fn empty() -> String* {
        String* result = new String("", 0);
        return result;
    }
    
    // Get byte length (O(1))
    fn len(self) -> int {
        return self.length;
    }
    
    // Check if empty
    fn is_empty(self) -> bool {
        return self.length == 0;
    }
    
    // Get UTF-8 character count (O(n))
    fn char_len(self) -> int {
        int char_count = 0;
        int pos = 0;
        
        while (pos < self.length) {
            int byte = self.data[pos];
            char_count = char_count + 1;
            
            if ((byte & 0x80) == 0) {
                pos = pos + 1;
            } else if ((byte & 0xE0) == 0xC0) {
                pos = pos + 2;
            } else if ((byte & 0xF0) == 0xE0) {
                pos = pos + 3;
            } else if ((byte & 0xF8) == 0xF0) {
                pos = pos + 4;
            } else {
                pos = pos + 1;
            }
        }
        
        return char_count;
    }
    
    // Concatenate with another string
    fn concat(self, other: String*) -> String* {
        int total_len = self.length + other.length;
        
        // Allocate memory
        int alloc_size = 8 + total_len + 1;
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return String.empty();
        }
        
        int* len_header = mapped;
        *len_header = total_len;
        
        str* result_data = mapped + 8;
        
        if (self.length > 0) {
            __memcpy(result_data, self.data, self.length);
        }
        
        if (other.length > 0) {
            __memcpy(result_data + self.length, other.data, other.length);
        }
        
        result_data[total_len] = 0;
        
        String* result = new String(result_data, total_len);
        return result;
    }
    
    // Get substring (returns view)
    fn slice(self, start: int, end: int) -> String* {
        if (start < 0 || end > self.length || start > end) {
            return String.empty();
        }
        
        String* result = new String(self.data + start, end - start);
        return result;
    }
    
    // Safe slice returning Option
    fn try_slice(self, start: int, end: int) -> Option<String*> {
        if (start < 0 || end > self.length || start > end) {
            return Option<String*>::none();
        }
        
        String* result = new String(self.data + start, end - start);
        return Option<String*>(result);
    }
    
    // Check if contains substring
    fn contains(self, substr: str*) -> bool {
        int substr_len = String._raw_len(substr);
        
        if (substr_len == 0) {
            return true;
        }
        
        if (substr_len > self.length) {
            return false;
        }
        
        int max_pos = self.length - substr_len;
        int pos = 0;
        
        while (pos <= max_pos) {
            bool match = true;
            int i = 0;
            
            while (i < substr_len && match) {
                if (self.data[pos + i] != substr[i]) {
                    match = false;
                }
                i = i + 1;
            }
            
            if (match) {
                return true;
            }
            
            pos = pos + 1;
        }
        
        return false;
    }
    
    // Check if starts with prefix
    fn starts_with(self, prefix: str*) -> bool {
        int prefix_len = String._raw_len(prefix);
        
        if (prefix_len > self.length) {
            return false;
        }
        
        int i = 0;
        while (i < prefix_len) {
            if (self.data[i] != prefix[i]) {
                return false;
            }
            i = i + 1;
        }
        
        return true;
    }
    
    // Check if ends with suffix
    fn ends_with(self, suffix: str*) -> bool {
        int suffix_len = String._raw_len(suffix);
        
        if (suffix_len > self.length) {
            return false;
        }
        
        int start = self.length - suffix_len;
        int i = 0;
        
        while (i < suffix_len) {
            if (self.data[start + i] != suffix[i]) {
                return false;
            }
            i = i + 1;
        }
        
        return true;
    }
    
    // Find substring position
    fn find(self, substr: str*) -> Option<int> {
        int substr_len = String._raw_len(substr);
        
        if (substr_len == 0) {
            return Option<int>(0);
        }
        
        if (substr_len > self.length) {
            return Option<int>::none();
        }
        
        int max_pos = self.length - substr_len;
        int pos = 0;
        
        while (pos <= max_pos) {
            bool match = true;
            int i = 0;
            
            while (i < substr_len && match) {
                if (self.data[pos + i] != substr[i]) {
                    match = false;
                }
                i = i + 1;
            }
            
            if (match) {
                return Option<int>(pos);
            }
            
            pos = pos + 1;
        }
        
        return Option<int>::none();
    }
    
    // Check equality
    fn equals(self, other: String*) -> bool {
        if (self.length != other.length) {
            return false;
        }
        
        return __memcmp(self.data, other.data, self.length) == 0;
    }
    
    // Compare lexicographically
    fn compare(self, other: String*) -> int {
        int min_len = self.length < other.length ? self.length : other.length;
        
        int result = __memcmp(self.data, other.data, min_len);
        
        if (result != 0) {
            return result;
        }
        
        return self.length - other.length;
    }
    
    // Convert to lowercase (in place)
    fn to_lower(self) -> void {
        int i = 0;
        while (i < self.length) {
            int c = self.data[i];
            if (c >= 65 && c <= 90) {
                self.data[i] = c + 32;
            }
            i = i + 1;
        }
    }
    
    // Convert to uppercase (in place)
    fn to_upper(self) -> void {
        int i = 0;
        while (i < self.length) {
            int c = self.data[i];
            if (c >= 97 && c <= 122) {
                self.data[i] = c - 32;
            }
            i = i + 1;
        }
    }
    
    // Trim whitespace
    fn trim(self) -> String* {
        int start = 0;
        int end = self.length;
        
        while (start < self.length) {
            int c = self.data[start];
            if (c != 32 && c != 9 && c != 10 && c != 13) {
                break;
            }
            start = start + 1;
        }
        
        while (end > start) {
            int c = self.data[end - 1];
            if (c != 32 && c != 9 && c != 10 && c != 13) {
                break;
            }
            end = end - 1;
        }
        
        return self.slice(start, end);
    }
    
    // Get byte at index
    fn char_at(self, index: int) -> Option<int> {
        if (index < 0 || index >= self.length) {
            return Option<int>::none();
        }
        return Option<int>(self.data[index]);
    }
    
    // Set byte at index
    fn set_char(self, index: int, c: int) -> void {
        if (index >= 0 && index < self.length) {
            self.data[index] = c;
        }
    }
    
    // Print to stdout
    fn print(self) -> void {
        syscall SYS_WRITE, STDOUT, self.data, self.length, ERRNO;
    }
    
    // Print with newline
    fn println(self) -> void {
        self.print();
        syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
    }
    
    // Internal: get raw string length
    fn _raw_len(s: str*) -> int {
        int* len_ptr = (s - 8);
        return *len_ptr;
    }
}

// =============================================================================
// Integer Type with OOP Methods
// =============================================================================

struct Int {
    value: int;
}

impl Int {
    constructor(v: int) {
        self.value = v;
    }
    
    // Absolute value
    fn abs(self) -> Int* {
        if (self.value < 0) {
            return new Int(-self.value);
        }
        return new Int(self.value);
    }
    
    // Absolute value with wrapping
    fn abs_wrapping(self) -> Int* {
        if (self.value < 0) {
            return new Int(-self.value);
        }
        return new Int(self.value);
    }
    
    // Clamp to range
    fn clamp(self, min_val: int, max_val: int) -> Int* {
        if (self.value < min_val) {
            return new Int(min_val);
        }
        if (self.value > max_val) {
            return new Int(max_val);
        }
        return new Int(self.value);
    }
    
    // Min of two values
    fn min(self, other: int) -> int {
        if (self.value < other) {
            return self.value;
        }
        return other;
    }
    
    // Max of two values
    fn max(self, other: int) -> int {
        if (self.value > other) {
            return self.value;
        }
        return other;
    }
    
    // Power
    fn pow(self, exp: int) -> Int* {
        if (exp < 0) {
            return new Int(0);
        }
        
        if (exp == 0) {
            return new Int(1);
        }
        
        int result = 1;
        int base = self.value;
        int e = exp;
        
        while (e > 0) {
            if ((e & 1) == 1) {
                result = result * base;
            }
            base = base * base;
            e = e >> 1;
        }
        
        return new Int(result);
    }
    
    // Square root
    fn sqrt(self) -> Int* {
        if (self.value < 0) {
            return new Int(0);
        }
        if (self.value <= 1) {
            return new Int(self.value);
        }
        
        int x = self.value;
        int y = (x + 1) / 2;
        
        while (y < x) {
            x = y;
            y = (x + self.value / x) / 2;
        }
        
        return new Int(x);
    }
    
    // Greatest common divisor
    fn gcd(self, other: int) -> Int* {
        int a = self.value;
        int b = other;
        
        if (a < 0) { a = -a; }
        if (b < 0) { b = -b; }
        
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        
        return new Int(a);
    }
    
    // Least common multiple
    fn lcm(self, other: int) -> Int* {
        if (self.value == 0 || other == 0) {
            return new Int(0);
        }
        
        int gcd = self.gcd(other).value;
        int abs_a = self.abs().value;
        int abs_b = other < 0 ? -other : other;
        
        return new Int((abs_a / gcd) * abs_b);
    }
    
    // Count set bits
    fn popcount(self) -> Int* {
        int count = 0;
        int n = self.value;
        
        while (n != 0) {
            count = count + 1;
            n = n & (n - 1);
        }
        
        return new Int(count);
    }
    
    // Trailing zeros
    fn trailing_zeros(self) -> Int* {
        if (self.value == 0) {
            return new Int(64);
        }
        
        int count = 0;
        int n = self.value;
        
        while ((n & 1) == 0) {
            count = count + 1;
            n = n >> 1;
        }
        
        return new Int(count);
    }
    
    // Leading zeros
    fn leading_zeros(self) -> Int* {
        if (self.value == 0) {
            return new Int(64);
        }
        
        int n = self.value;
        int count = 0;
        
        if ((n & 0xFFFFFFFF00000000) == 0) { count = count + 32; n = n << 32; }
        if ((n & 0xFFFF000000000000) == 0) { count = count + 16; n = n << 16; }
        if ((n & 0xFF00000000000000) == 0) { count = count + 8; n = n << 8; }
        if ((n & 0xF000000000000000) == 0) { count = count + 4; n = n << 4; }
        if ((n & 0xC000000000000000) == 0) { count = count + 2; n = n << 2; }
        if ((n & 0x8000000000000000) == 0) { count = count + 1; }
        
        return new Int(count);
    }
    
    // Convert to string
    fn to_str(self) -> String* {
        if (self.value == 0) {
            return new String("0", 1);
        }
        
        int is_negative = self.value < 0;
        int n = is_negative ? -self.value : self.value;
        
        // Count digits
        int digit_count = 0;
        int temp = n;
        while (temp > 0) {
            digit_count = digit_count + 1;
            temp = temp / 10;
        }
        
        int total_len = digit_count;
        if (is_negative) {
            total_len = total_len + 1;
        }
        
        // Allocate memory
        int alloc_size = 8 + total_len + 1;
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return String.empty();
        }
        
        int* len_header = mapped;
        *len_header = total_len;
        
        str* result_data = mapped + 8;
        
        int pos = total_len - 1;
        while (n > 0) {
            int digit = n % 10;
            result_data[pos] = 48 + digit;
            n = n / 10;
            pos = pos - 1;
        }
        
        if (is_negative) {
            result_data[0] = 45;
        }
        
        result_data[total_len] = 0;
        
        return new String(result_data, total_len);
    }
    
    // Parse from string
    fn from_str(s: str*) -> Int* {
        int len = String._raw_len(s);
        
        if (len == 0) {
            return new Int(0);
        }
        
        int pos = 0;
        int result = 0;
        int negative = 0;
        
        // Skip whitespace
        while (pos < len) {
            int c = s[pos];
            if (c != 32 && c != 9 && c != 10 && c != 13) {
                break;
            }
            pos = pos + 1;
        }
        
        // Check sign
        if (pos < len) {
            if (s[pos] == 45) {
                negative = 1;
                pos = pos + 1;
            } else if (s[pos] == 43) {
                pos = pos + 1;
            }
        }
        
        // Parse digits
        while (pos < len) {
            int c = s[pos];
            
            if (c < 48 || c > 57) {
                break;
            }
            
            result = result * 10 + (c - 48);
            pos = pos + 1;
        }
        
        if (negative) {
            result = -result;
        }
        
        return new Int(result);
    }
    
    // Sign
    fn sign(self) -> Int* {
        if (self.value < 0) { return new Int(-1); }
        if (self.value > 0) { return new Int(1); }
        return new Int(0);
    }
    
    // Is power of two
    fn is_power_of_two(self) -> bool {
        return self.value > 0 && (self.value & (self.value - 1)) == 0;
    }
    
    // Next power of two
    fn next_power_of_two(self) -> Int* {
        if (self.value <= 1) {
            return new Int(1);
        }
        
        int n = self.value - 1;
        
        n = n | (n >> 1);
        n = n | (n >> 2);
        n = n | (n >> 4);
        n = n | (n >> 8);
        n = n | (n >> 16);
        n = n | (n >> 32);
        
        return new Int(n + 1);
    }
    
    // Print to stdout
    fn print(self) -> void {
        String* s = self.to_str();
        s.print();
    }
    
    // Print with newline
    fn println(self) -> void {
        String* s = self.to_str();
        s.println();
    }
}

// =============================================================================
// Float Type with OOP Methods
// =============================================================================

struct Float {
    value: float;
}

impl Float {
    constructor(v: float) {
        self.value = v;
    }
    
    // Absolute value
    fn abs(self) -> Float* {
        return new Float(__fabs(self.value));
    }
    
    // Floor
    fn floor(self) -> Float* {
        return new Float(__floor(self.value));
    }
    
    // Ceiling
    fn ceil(self) -> Float* {
        return new Float(__ceil(self.value));
    }
    
    // Round
    fn round(self) -> Float* {
        return new Float(__round(self.value));
    }
    
    // Square root
    fn sqrt(self) -> Float* {
        return new Float(__sqrt(self.value));
    }
    
    // Power
    fn pow(self, exp: float) -> Float* {
        return new Float(__pow(self.value, exp));
    }
    
    // Sine
    fn sin(self) -> Float* {
        return new Float(__sin(self.value));
    }
    
    // Cosine
    fn cos(self) -> Float* {
        return new Float(__cos(self.value));
    }
    
    // Tangent
    fn tan(self) -> Float* {
        return new Float(__tan(self.value));
    }
    
    // Check if NaN
    fn is_nan(self) -> bool {
        return __isnan(self.value);
    }
    
    // Check if infinity
    fn is_inf(self) -> bool {
        return __isinf(self.value);
    }
    
    // Check if finite
    fn is_finite(self) -> bool {
        return !__isnan(self.value) && !__isinf(self.value);
    }
    
    // Min of two
    fn min(self, other: float) -> float {
        return self.value < other ? self.value : other;
    }
    
    // Max of two
    fn max(self, other: float) -> float {
        return self.value > other ? self.value : other;
    }
    
    // Clamp to range
    fn clamp(self, min_val: float, max_val: float) -> Float* {
        if (self.value < min_val) {
            return new Float(min_val);
        }
        if (self.value > max_val) {
            return new Float(max_val);
        }
        return new Float(self.value);
    }
    
    // Convert to string
    fn to_str(self) -> String* {
        // This would use a float-to-string conversion
        // For now, simplified version using intrinsic
        str* buffer;
        __ftoa(self.value, buffer);
        return new String(buffer, String._raw_len(buffer));
    }
    
    // Parse from string
    fn from_str(s: str*) -> Float* {
        float result = __atof(s);
        return new Float(result);
    }
    
    // Print to stdout
    fn print(self) -> void {
        String* s = self.to_str();
        s.print();
    }
    
    // Print with newline
    fn println(self) -> void {
        String* s = self.to_str();
        s.println();
    }
}

// =============================================================================
// Array Type with OOP Methods
// =============================================================================

struct Array<T> {
    data: T*;
    length: int;
    capacity: int;
}

impl Array<T> {
    // Create empty array
    constructor() {
        self.data = 0;
        self.length = 0;
        self.capacity = 0;
    }
    
    // Create with initial capacity
    fn with_capacity(cap: int) -> Array<T>* {
        int alloc_size = 8 + cap * 8;  // 8 bytes per element
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        Array<T>* arr = new Array<T>();
        if (mapped != -1) {
            arr.data = mapped + 8;
            arr.length = 0;
            arr.capacity = cap;
        }
        return arr;
    }
    
    // Create from static array
    fn from_static(data: T*, len: int) -> Array<T>* {
        Array<T>* arr = Array<T>.with_capacity(len);
        arr.length = len;
        
        int i = 0;
        while (i < len) {
            arr.data[i] = data[i];
            i = i + 1;
        }
        
        return arr;
    }
    
    // Get length
    fn len(self) -> int {
        return self.length;
    }
    
    // Check if empty
    fn is_empty(self) -> bool {
        return self.length == 0;
    }
    
    // Safe element access
    fn get(self, index: int) -> Option<T> {
        if (index < 0 || index >= self.length) {
            return Option<T>::none();
        }
        return Option<T>(self.data[index]);
    }
    
    // Unsafe element access (panics on out of bounds)
    fn at(self, index: int) -> T {
        if (index < 0 || index >= self.length) {
            // Panic - would ideally call panic function
            syscall SYS_EXIT, 1, ERRNO;
        }
        return self.data[index];
    }
    
    // Set element
    fn set(self, index: int, value: T) -> void {
        if (index >= 0 && index < self.length) {
            self.data[index] = value;
        }
    }
    
    // Push element
    fn push(self, value: T) -> void {
        if (self.length >= self.capacity) {
            // Grow array
            int new_cap = self.capacity == 0 ? 4 : self.capacity * 2;
            self._grow(new_cap);
        }
        
        self.data[self.length] = value;
        self.length = self.length + 1;
    }
    
    // Pop element
    fn pop(self) -> Option<T> {
        if (self.length == 0) {
            return Option<T>::none();
        }
        
        self.length = self.length - 1;
        return Option<T>(self.data[self.length]);
    }
    
    // Get first element
    fn first(self) -> Option<T> {
        if (self.length == 0) {
            return Option<T>::none();
        }
        return Option<T>(self.data[0]);
    }
    
    // Get last element
    fn last(self) -> Option<T> {
        if (self.length == 0) {
            return Option<T>::none();
        }
        return Option<T>(self.data[self.length - 1]);
    }
    
    // Clear array
    fn clear(self) -> void {
        self.length = 0;
    }
    
    // Internal: grow capacity
    fn _grow(self, new_cap: int) -> void {
        int alloc_size = 8 + new_cap * 8;
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return;
        }
        
        T* new_data = mapped + 8;
        
        // Copy old data
        int i = 0;
        while (i < self.length) {
            new_data[i] = self.data[i];
            i = i + 1;
        }
        
        // Free old data if it was allocated
        if (self.data != 0) {
            // Note: would need to track the base pointer for munmap
        }
        
        self.data = new_data;
        self.capacity = new_cap;
    }
    
    // Print array (for int arrays)
    fn print(self) -> void {
        int i = 0;
        syscall SYS_WRITE, STDOUT, "[", 1, ERRNO;
        
        while (i < self.length) {
            if (i > 0) {
                syscall SYS_WRITE, STDOUT, ", ", 2, ERRNO;
            }
            Int* val = new Int(self.data[i]);
            val.print();
            i = i + 1;
        }
        
        syscall SYS_WRITE, STDOUT, "]", 1, ERRNO;
    }
}

// =============================================================================
// Bytes Type with OOP Methods
// =============================================================================

struct Bytes {
    data: bytes*;
    length: int;
}

impl Bytes {
    // Create empty bytes
    constructor() {
        self.data = 0;
        self.length = 0;
    }
    
    // Create with size
    fn with_size(size: int) -> Bytes* {
        int alloc_size = 8 + size;
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        Bytes* b = new Bytes();
        if (mapped != -1) {
            b.data = mapped + 8;
            b.length = size;
        }
        return b;
    }
    
    // Create from data
    fn from_data(data: bytes*, len: int) -> Bytes* {
        Bytes* b = Bytes.with_size(len);
        
        int i = 0;
        while (i < len) {
            b.data[i] = data[i];
            i = i + 1;
        }
        
        return b;
    }
    
    // Get length
    fn len(self) -> int {
        return self.length;
    }
    
    // Check if empty
    fn is_empty(self) -> bool {
        return self.length == 0;
    }
    
    // Safe byte access
    fn get(self, index: int) -> Option<int> {
        if (index < 0 || index >= self.length) {
            return Option<int>::none();
        }
        return Option<int>(self.data[index]);
    }
    
    // Set byte
    fn set(self, index: int, value: int) -> void {
        if (index >= 0 && index < self.length) {
            self.data[index] = value;
        }
    }
    
    // Copy from another bytes
    fn copy_from(self, src: Bytes*, offset: int) -> void {
        int i = 0;
        while (i < src.length && (offset + i) < self.length) {
            self.data[offset + i] = src.data[i];
            i = i + 1;
        }
    }
    
    // Convert to string (assuming valid UTF-8)
    fn to_string(self) -> String* {
        return new String(self.data, self.length);
    }
    
    // Convert to hex string
    fn to_hex(self) -> String* {
        int hex_len = self.length * 2;
        
        int alloc_size = 8 + hex_len + 1;
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return String.empty();
        }
        
        int* len_header = mapped;
        *len_header = hex_len;
        
        str* hex_data = mapped + 8;
        
        int i = 0;
        while (i < self.length) {
            int b = self.data[i];
            int high = (b >> 4) & 0x0F;
            int low = b & 0x0F;
            
            hex_data[i * 2] = high < 10 ? 48 + high : 97 + high - 10;
            hex_data[i * 2 + 1] = low < 10 ? 48 + low : 97 + low - 10;
            
            i = i + 1;
        }
        
        hex_data[hex_len] = 0;
        
        return new String(hex_data, hex_len);
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

// Memory copy
fn mem_copy(dest: void*, src: void*, n: int) -> void* {
    __memcpy(dest, src, n);
    return dest;
}

// Memory set
fn mem_set(dest: void*, value: int, n: int) -> void* {
    __memset(dest, value, n);
    return dest;
}

// Memory compare
fn mem_compare(s1: void*, s2: void*, n: int) -> int {
    return __memcmp(s1, s2, n);
}

// Memory move (handles overlapping)
fn mem_move(dest: void*, src: void*, n: int) -> void* {
    // Check for overlap
    if (dest < src || dest >= src + n) {
        // No overlap or forward copy - copy from start
        __memcpy(dest, src, n);
    } else {
        // Overlap - copy from end
        int i = n;
        while (i > 0) {
            i = i - 1;
            ((bytes*)dest)[i] = ((bytes*)src)[i];
        }
    }
    return dest;
}

// Memory zero
fn mem_zero(dest: void*, n: int) -> void* {
    __memset(dest, 0, n);
    return dest;
}

// =============================================================================
// Python-like Print Functions
// =============================================================================

// Print buffer for formatted output
struct PrintBuffer {
    data: bytes*;
    pos: int;
    capacity: int;
}

impl PrintBuffer {
    fn new(cap: int) -> PrintBuffer* {
        int alloc_size = 8 + cap;
        alloc_size = (alloc_size + 15) & ~15;
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        PrintBuffer* pb = new PrintBuffer();
        if (mapped != -1) {
            pb.data = mapped + 8;
            pb.pos = 0;
            pb.capacity = cap;
        }
        return pb;
    }
    
    fn write_char(self, c: int) -> void {
        if (self.pos < self.capacity) {
            self.data[self.pos] = c;
            self.pos = self.pos + 1;
        }
    }
    
    fn write_str(self, s: str*) -> void {
        int len = String._raw_len(s);
        int i = 0;
        while (i < len && self.pos < self.capacity) {
            self.data[self.pos] = s[i];
            self.pos = self.pos + 1;
            i = i + 1;
        }
    }
    
    fn write_int(self, n: int) -> void {
        if (n == 0) {
            self.write_char(48);
            return;
        }
        
        int is_neg = n < 0;
        int val = is_neg ? -n : n;
        
        bytes buf<21>;
        int count = 0;
        
        while (val > 0) {
            buf[count] = 48 + (val % 10);
            val = val / 10;
            count = count + 1;
        }
        
        if (is_neg) {
            self.write_char(45);
        }
        
        int i = count - 1;
        while (i >= 0) {
            self.write_char(buf[i]);
            i = i - 1;
        }
    }
    
    fn write_bool(self, b: bool) -> void {
        if (b) {
            self.write_str("true");
        } else {
            self.write_str("false");
        }
    }
    
    fn write_float(self, f: float) -> void {
        str* buf;
        __ftoa(f, buf);
        self.write_str(buf);
    }
    
    fn write_pointer(self, p: void*) -> void {
        self.write_str("0x");
        int val = (int)p;
        int i = 60;
        while (i >= 0) {
            int nibble = (val >> i) & 0xF;
            self.write_char(nibble < 10 ? 48 + nibble : 97 + nibble - 10);
            i = i - 4;
        }
    }
    
    fn flush(self) -> void {
        syscall SYS_WRITE, STDOUT, self.data, self.pos, ERRNO;
        self.pos = 0;
    }
    
    fn flush_with_newline(self) -> void {
        self.write_char(10);
        syscall SYS_WRITE, STDOUT, self.data, self.pos, ERRNO;
        self.pos = 0;
    }
    
    fn clear(self) -> void {
        self.pos = 0;
    }
}

// Global print buffer
PrintBuffer* _print_buf = 0;

fn _get_print_buf() -> PrintBuffer* {
    if (_print_buf == 0) {
        _print_buf = PrintBuffer.new(4096);
    }
    return _print_buf;
}

// Print string literal
fn print(s: str) -> void {
    int len = String._raw_len(s);
    syscall SYS_WRITE, STDOUT, s, len, ERRNO;
}

// Print string literal with newline
fn println(s: str) -> void {
    int len = String._raw_len(s);
    syscall SYS_WRITE, STDOUT, s, len, ERRNO;
    syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
}

// Print integer
fn printi(n: int) -> void {
    Int* i = new Int(n);
    i.print();
}

// Print float
fn printfl(f: float) -> void {
    Float* fl = new Float(f);
    fl.print();
}

// Print bool
fn printb(b: bool) -> void {
    if (b) {
        syscall SYS_WRITE, STDOUT, "true", 4, ERRNO;
    } else {
        syscall SYS_WRITE, STDOUT, "false", 5, ERRNO;
    }
}

// Print pointer as hex
fn printp(p: void*) -> void {
    PrintBuffer* buf = _get_print_buf();
    buf.write_pointer(p);
    buf.flush();
}

// Print with newline variants
fn printiln(n: int) -> void {
    printi(n);
    syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
}

fn printfln(f: float) -> void {
    printfl(f);
    syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
}

fn printbln(b: bool) -> void {
    printb(b);
    syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
}

// Print multiple items with separator
fn print_sep(sep: str, items: str**, count: int) -> void {
    int i = 0;
    while (i < count) {
        if (i > 0) {
            print(sep);
        }
        print(items[i]);
        i = i + 1;
    }
}

// Print multiple items with separator and newline
fn print_sepln(sep: str, items: str**, count: int) -> void {
    print_sep(sep, items, count);
    syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
}

// Print array of integers
fn print_arr_int(arr: int*, len: int) -> void {
    syscall SYS_WRITE, STDOUT, "[", 1, ERRNO;
    
    int i = 0;
    while (i < len) {
        if (i > 0) {
            syscall SYS_WRITE, STDOUT, ", ", 2, ERRNO;
        }
        printi(arr[i]);
        i = i + 1;
    }
    
    syscall SYS_WRITE, STDOUT, "]", 1, ERRNO;
}

fn print_arr_intln(arr: int*, len: int) -> void {
    print_arr_int(arr, len);
    syscall SYS_WRITE, STDOUT, "\n", 1, ERRNO;
}

// Print error to stderr
fn eprint(s: str) -> void {
    int len = String._raw_len(s);
    syscall SYS_WRITE, STDERR, s, len, ERRNO;
}

fn eprintln(s: str) -> void {
    int len = String._raw_len(s);
    syscall SYS_WRITE, STDERR, s, len, ERRNO;
    syscall SYS_WRITE, STDERR, "\n", 1, ERRNO;
}

// Exit program
fn exit(code: int) -> void {
    syscall SYS_EXIT, code, ERRNO;
}

// Exit with error message
fn die(msg: str) -> void {
    eprintln(msg);
    exit(1);
}
