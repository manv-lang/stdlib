// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/dotenv/dotenv.mv
// description: Environment variable file parsing module with OOP design
//
// This module provides .env file parsing functions using impl blocks.
// All functions are implemented in pure ManV.
//
// Types:
// -------
// - EnvFile     - Parsed environment file
// - EnvVar      - Environment variable entry
// - EnvBuilder  - Builder for .env files
//
// Functions:
// ----------
// - dotenv_load(path)      - Load .env file
// - dotenv_get(key)        - Get environment variable
// - dotenv_set(key, val)   - Set environment variable
// - dotenv_parse(content)  - Parse env content string
//
// Examples:
// ---------
// // Load .env file
// EnvFile* env = dotenv_load(".env");
// str* db_url = env.get("DATABASE_URL");
//
// // Parse env string
// EnvFile* env = dotenv_parse("KEY=value\nOTHER=123");
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Syscall numbers
int SYS_OPEN = 2;
int SYS_READ = 0;
int SYS_CLOSE = 3;
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;
int SYS_STAT = 4;

// File flags
int O_RDONLY = 0;

// Memory protection
int PROT_READ = 1;
int PROT_WRITE = 2;
int MAP_PRIVATE = 2;
int MAP_ANONYMOUS = 32;

// Error handling
int ERRNO;

// =============================================================================
// EnvVar Type
// =============================================================================

struct EnvVar {
    key: str*;
    value: str*;
    quoted: bool;
    comment: str*;
}

impl EnvVar {
    fn new(key: str*, value: str*) -> EnvVar* {
        EnvVar* v = new EnvVar();
        v.key = key;
        v.value = value;
        v.quoted = false;
        v.comment = "";
        return v;
    }
    
    fn with_quote(key: str*, value: str*, quoted: bool) -> EnvVar* {
        EnvVar* v = new EnvVar();
        v.key = key;
        v.value = value;
        v.quoted = quoted;
        v.comment = "";
        return v;
    }
    
    fn with_comment(key: str*, value: str*, comment: str*) -> EnvVar* {
        EnvVar* v = new EnvVar();
        v.key = key;
        v.value = value;
        v.quoted = false;
        v.comment = comment;
        return v;
    }
    
    fn get_key(self) -> str* {
        return self.key;
    }
    
    fn get_value(self) -> str* {
        return self.value;
    }
    
    fn is_quoted(self) -> bool {
        return self.quoted;
    }
}

// =============================================================================
// EnvFile Type
// =============================================================================

struct EnvFile {
    vars: array<EnvVar*>;
    keys: array<str*>;
    len: int;
    path: str*;
}

impl EnvFile {
    constructor() {
        self.vars = [];
        self.keys = [];
        self.len = 0;
        self.path = "";
    }
    
    fn new() -> EnvFile* {
        EnvFile* env = new EnvFile();
        env.vars = [];
        env.keys = [];
        env.len = 0;
        env.path = "";
        return env;
    }
    
    // Load from file path
    fn load(path: str*) -> EnvFile* {
        EnvFile* env = EnvFile.new();
        env.path = path;
        
        // Open file
        int fd;
        syscall SYS_OPEN, path, O_RDONLY, 0, fd, ERRNO;
        
        if (fd < 0) {
            return env;
        }
        
        // Get file size (would need stat)
        int size = 4096;  // Default buffer size
        
        // Allocate buffer
        void* mapped;
        syscall SYS_MMAP, 0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            syscall SYS_CLOSE, fd, ERRNO;
            return env;
        }
        
        // Read file
        int bytes_read;
        syscall SYS_READ, fd, mapped, size, bytes_read, ERRNO;
        
        syscall SYS_CLOSE, fd, ERRNO;
        
        // Parse content
        if (bytes_read > 0) {
            env._parse(mapped, bytes_read);
        }
        
        // Free buffer
        syscall SYS_MUNMAP, mapped, size, ERRNO;
        
        return env;
    }
    
    // Parse content
    fn _parse(self, content: bytes*, len: int) -> void {
        int i = 0;
        int line_start = 0;
        
        while (i <= len) {
            int c = (i < len) ? content[i] : 10;  // Treat end as newline
            
            if (c == 10) {  // newline
                if (i > line_start) {
                    self._parse_line(content + line_start, i - line_start);
                }
                line_start = i + 1;
            }
            i = i + 1;
        }
    }
    
    // Parse single line
    fn _parse_line(self, line: bytes*, len: int) -> void {
        int i = 0;
        
        // Skip leading whitespace
        while (i < len && (line[i] == 32 || line[i] == 9)) {
            i = i + 1;
        }
        
        // Skip empty lines and comments
        if (i >= len || line[i] == 35) {  // '#'
            return;
        }
        
        // Find key
        int key_start = i;
        while (i < len && line[i] != 61 && line[i] != 32 && line[i] != 9) {  // '=', space, tab
            i = i + 1;
        }
        int key_end = i;
        
        if (key_start >= key_end) {
            return;
        }
        
        // Extract key
        str* key = _extract_string(line + key_start, key_end - key_start);
        
        // Skip whitespace and '='
        while (i < len && (line[i] == 32 || line[i] == 9)) {
            i = i + 1;
        }
        if (i < len && line[i] == 61) {  // '='
            i = i + 1;
        }
        while (i < len && (line[i] == 32 || line[i] == 9)) {
            i = i + 1;
        }
        
        // Parse value
        str* value = "";
        bool quoted = false;
        
        if (i < len) {
            if (line[i] == 34 || line[i] == 39) {  // '"' or "'"
                quoted = true;
                int quote = line[i];
                i = i + 1;
                int val_start = i;
                
                while (i < len && line[i] != quote) {
                    i = i + 1;
                }
                
                value = _extract_string(line + val_start, i - val_start);
            } else {
                int val_start = i;
                
                // Value until comment or end
                while (i < len && line[i] != 35 && line[i] != 32 && line[i] != 9) {  // '#', space, tab
                    i = i + 1;
                }
                
                value = _extract_string(line + val_start, i - val_start);
            }
        }
        
        // Store variable
        EnvVar* var = EnvVar.with_quote(key, value, quoted);
        self._set(key, value);
        self.vars[self.len] = var;
        self.keys[self.len] = key;
        self.len = self.len + 1;
    }
    
    // Get value by key
    fn get(self, key: str*) -> str* {
        int i = 0;
        while (i < self.len) {
            if (_str_eq(self.keys[i], key)) {
                return self.vars[i].value;
            }
            i = i + 1;
        }
        return "";
    }
    
    // Set value
    fn _set(self, key: str*, value: str*) -> void {
        // Check if key exists
        int i = 0;
        while (i < self.len) {
            if (_str_eq(self.keys[i], key)) {
                self.vars[i].value = value;
                return;
            }
            i = i + 1;
        }
        
        // Add new
        if (self.len < 256) {  // Max 256 vars
            EnvVar* var = EnvVar.new(key, value);
            self.vars[self.len] = var;
            self.keys[self.len] = key;
            self.len = self.len + 1;
        }
    }
    
    // Check if key exists
    fn has(self, key: str*) -> bool {
        int i = 0;
        while (i < self.len) {
            if (_str_eq(self.keys[i], key)) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
    
    // Get all keys
    fn keys_len(self) -> int {
        return self.len;
    }
    
    // Get key at index
    fn key_at(self, index: int) -> str* {
        if (index < 0 || index >= self.len) {
            return "";
        }
        return self.keys[index];
    }
    
    // Get value at index
    fn value_at(self, index: int) -> str* {
        if (index < 0 || index >= self.len) {
            return "";
        }
        return self.vars[index].value;
    }
    
    // Remove key
    fn remove(self, key: str*) -> bool {
        int i = 0;
        while (i < self.len) {
            if (_str_eq(self.keys[i], key)) {
                int j = i;
                while (j < self.len - 1) {
                    self.keys[j] = self.keys[j + 1];
                    self.vars[j] = self.vars[j + 1];
                    j = j + 1;
                }
                self.len = self.len - 1;
                return true;
            }
            i = i + 1;
        }
        return false;
    }
    
    // Get int value
    fn get_int(self, key: str*) -> int {
        str* val = self.get(key);
        return _str_to_int(val);
    }
    
    // Get bool value
    fn get_bool(self, key: str*) -> bool {
        str* val = self.get(key);
        return _str_eq(val, "true") || _str_eq(val, "1") || _str_eq(val, "yes");
    }
    
    // Write to file
    fn save(self, path: str*) -> bool {
        // Would write file
        return true;
    }
}

// =============================================================================
// EnvBuilder Type
// =============================================================================

struct EnvBuilder {
    buffer: bytes*;
    pos: int;
    capacity: int;
}

impl EnvBuilder {
    constructor() {
        self.buffer = 0;
        self.pos = 0;
        self.capacity = 0;
    }
    
    fn new() -> EnvBuilder* {
        EnvBuilder* b = new EnvBuilder();
        b.capacity = 4096;
        b.pos = 0;
        return b;
    }
    
    // Add variable
    fn add(self, key: str*, value: str*) -> void {
        self._write_key(key);
        self._write_char(61);  // '='
        self._write_value(value);
        self._write_char(10);  // newline
    }
    
    // Add quoted variable
    fn add_quoted(self, key: str*, value: str*) -> void {
        self._write_key(key);
        self._write_char(61);  // '='
        self._write_char(34);  // '"'
        self._write_str(value);
        self._write_char(34);  // '"'
        self._write_char(10);  // newline
    }
    
    // Add comment
    fn comment(self, text: str*) -> void {
        self._write_char(35);  // '#'
        self._write_str(text);
        self._write_char(10);  // newline
    }
    
    // Add empty line
    fn empty_line(self) -> void {
        self._write_char(10);
    }
    
    // Get result
    fn finish(self) -> str* {
        return self.buffer;
    }
    
    // Internal: write key
    fn _write_key(self, key: str*) -> void {
        self._write_str(key);
    }
    
    // Internal: write value
    fn _write_value(self, value: str*) -> void {
        // Check if needs quoting
        int len = _strlen(value);
        bool needs_quote = false;
        int i = 0;
        
        while (i < len) {
            int c = value[i];
            if (c == 32 || c == 9 || c == 35 || c == 10) {  // space, tab, #, newline
                needs_quote = true;
                break;
            }
            i = i + 1;
        }
        
        if (needs_quote) {
            self._write_char(34);  // '"'
            self._write_str(value);
            self._write_char(34);  // '"'
        } else {
            self._write_str(value);
        }
    }
    
    // Internal: write string
    fn _write_str(self, s: str*) -> void {
        int len = _strlen(s);
        int i = 0;
        while (i < len) {
            self.buffer[self.pos] = s[i];
            self.pos = self.pos + 1;
            i = i + 1;
        }
    }
    
    // Internal: write char
    fn _write_char(self, c: int) -> void {
        self.buffer[self.pos] = c;
        self.pos = self.pos + 1;
    }
}

// =============================================================================
// Standalone Functions
// =============================================================================

// Global env storage
EnvFile* _global_env = 0;

// Load .env file
fn dotenv_load(path: str*) -> EnvFile* {
    return EnvFile.load(path);
}

// Parse env content string
fn dotenv_parse(content: str*) -> EnvFile* {
    EnvFile* env = EnvFile.new();
    int* len_ptr = (content - 8);
    env._parse(content, *len_ptr);
    return env;
}

// Get global env variable
fn dotenv_get(key: str*) -> str* {
    if (_global_env == 0) {
        _global_env = EnvFile.new();
    }
    return _global_env.get(key);
}

// Set global env variable
fn dotenv_set(key: str*, value: str*) -> void {
    if (_global_env == 0) {
        _global_env = EnvFile.new();
    }
    _global_env._set(key, value);
}

// Initialize global env from file
fn dotenv_init(path: str*) -> bool {
    _global_env = EnvFile.load(path);
    return _global_env.len > 0;
}

// Check if key exists in global env
fn dotenv_has(key: str*) -> bool {
    if (_global_env == 0) {
        return false;
    }
    return _global_env.has(key);
}

// =============================================================================
// Internal Helpers
// =============================================================================

fn _strlen(s: str*) -> int {
    if (s == 0) {
        return 0;
    }
    int* len_ptr = (s - 8);
    return *len_ptr;
}

fn _str_eq(a: str*, b: str*) -> bool {
    if (a == b) {
        return true;
    }
    if (a == 0 || b == 0) {
        return false;
    }
    
    int len_a = _strlen(a);
    int len_b = _strlen(b);
    
    if (len_a != len_b) {
        return false;
    }
    
    int i = 0;
    while (i < len_a) {
        if (a[i] != b[i]) {
            return false;
        }
        i = i + 1;
    }
    
    return true;
}

fn _extract_string(data: bytes*, len: int) -> str* {
    // Would allocate and copy string
    // Simplified for now
    return "";
}

fn _str_to_int(s: str*) -> int {
    if (s == 0) {
        return 0;
    }
    
    int len = _strlen(s);
    int result = 0;
    int neg = false;
    int i = 0;
    
    if (len > 0 && s[0] == 45) {  // '-'
        neg = true;
        i = 1;
    }
    
    while (i < len) {
        int c = s[i];
        if (c >= 48 && c <= 57) {
            result = result * 10 + (c - 48);
        }
        i = i + 1;
    }
    
    return neg ? -result : result;
}