// =============================================================================
// std.mem.alloc
// Low-level memory allocation functions.
// =============================================================================

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

// Syscall numbers for Linux x86-64
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;
int SYS_BRK = 12;

// Memory protection flags
int PROT_NONE = 0;
int PROT_READ = 1;
int PROT_WRITE = 2;
int PROT_EXEC = 4;

// Memory mapping flags
int MAP_SHARED = 1;
int MAP_PRIVATE = 2;
int MAP_FIXED = 16;
int MAP_ANONYMOUS = 32;

// Error handling
int ERRNO = 0;

// -----------------------------------------------------------------------------
// Memory Type - Low-level memory operations
// -----------------------------------------------------------------------------

struct Memory {
    // Static methods only - no instance data
}

impl Memory {
    // Allocate memory using mmap
    fn alloc(size: int) -> void* {
        int alloc_size = (size + 15) & ~15;  // Align to 16 bytes
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return 0;
        }
        
        return mapped;
    }
    
    // Allocate zeroed memory
    fn alloc_zeroed(size: int) -> void* {
        void* ptr = Memory.alloc(size);
        
        if (ptr != 0) {
            Memory.zero(ptr, size);
        }
        
        return ptr;
    }
    
    // Free memory using munmap
    fn free(ptr: void*, size: int) -> void {
        int alloc_size = (size + 15) & ~15;
        syscall SYS_MUNMAP, ptr, alloc_size, ERRNO;
    }
    
    // Copy memory
    fn copy(dest: void*, src: void*, n: int) -> void* {
        __memcpy(dest, src, n);
        return dest;
    }
    
    // Move memory (handles overlapping regions)
    fn move(dest: void*, src: void*, n: int) -> void* {
        __memmove(dest, src, n);
        return dest;
    }
    
    // Set memory to value
    fn set(dest: void*, value: int, n: int) -> void* {
        __memset(dest, value, n);
        return dest;
    }
    
    // Zero memory
    fn zero(dest: void*, n: int) -> void* {
        __memzero(dest, n);
        return dest;
    }
    
    // Compare memory
    fn compare(s1: void*, s2: void*, n: int) -> int {
        return __memcmp(s1, s2, n);
    }
    
    // Check if memory is zero
    fn is_zero(ptr: void*, n: int) -> bool {
        int i = 0;
        while (i < n) {
            if (((bytes*)ptr)[i] != 0) {
                return false;
            }
            i = i + 1;
        }
        return true;
    }
    
    // Align pointer up
    fn align_up(ptr: void*, alignment: int) -> void* {
        int addr = ptr;
        int aligned = (addr + alignment - 1) & ~(alignment - 1);
        return aligned;
    }
    
    // Align pointer down
    fn align_down(ptr: void*, alignment: int) -> void* {
        int addr = ptr;
        int aligned = addr & ~(alignment - 1);
        return aligned;
    }
    
    // Get page size (typically 4096)
    fn page_size() -> int {
        return 4096;
    }
    
    // Allocate aligned memory
    fn alloc_aligned(size: int, alignment: int) -> void* {
        // Allocate extra space for alignment
        int total_size = size + alignment;
        void* raw = Memory.alloc(total_size);
        
        if (raw == 0) {
            return 0;
        }
        
        // Align the pointer
        void* aligned = Memory.align_up(raw + 1, alignment);
        
        // Store the original pointer just before the aligned address
        void** header = aligned - 8;
        *header = raw;
        
        return aligned;
    }
    
    // Free aligned memory
    fn free_aligned(ptr: void*) -> void {
        // Get the original pointer from header
        void** header = ptr - 8;
        void* raw = *header;
        
        // We don't know the exact size, but munmap with the original mapping
        syscall SYS_MUNMAP, raw, 0, ERRNO;
    }
    
    // Calculate hash of memory region
    fn hash(ptr: void*, len: int) -> int {
        int h = 0;
        int i = 0;
        while (i < len) {
            h = ((h << 5) - h) + ((bytes*)ptr)[i];
            i = i + 1;
        }
        return h;
    }
    
    // Find byte in memory
    fn find_byte(ptr: void*, len: int, value: int) -> int {
        int i = 0;
        while (i < len) {
            if (((bytes*)ptr)[i] == value) {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

// Allocate memory
fn mem_alloc(size: int) -> void* {
    return Memory.alloc(size);
}

// Free memory
fn mem_free(ptr: void*, size: int) -> void {
    Memory.free(ptr, size);
}

// Copy memory
fn mem_copy(dest: void*, src: void*, n: int) -> void* {
    return Memory.copy(dest, src, n);
}

// Set memory
fn mem_set(dest: void*, value: int, n: int) -> void* {
    return Memory.set(dest, value, n);
}

// Zero memory
fn mem_zero(dest: void*, n: int) -> void* {
    return Memory.zero(dest, n);
}

// Compare memory
fn mem_compare(s1: void*, s2: void*, n: int) -> int {
    return Memory.compare(s1, s2, n);
}