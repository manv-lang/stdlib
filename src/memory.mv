// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: std/src/memory.mv
// description: Memory management module with OOP design
//
// This module provides a comprehensive memory management system with:
// - Arena: Bump allocator for deterministic deallocation
// - GC: Mark-sweep garbage collector for automatic management
// - Allocator: Low-level manual memory management
// - Buffer: Dynamic byte buffer with full API
// - Pool: Fixed-size object pool
//
// Key Features:
// - Type-safe allocation with ArenaRef<T> and GCRef<T>
// - Arena-to-GC promotion via ArenaRef.promote()
// - defer { } support for deterministic cleanup
// - Memory safety enforced at compile time
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Syscall numbers for Linux x86-64
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;
int SYS_BRK = 12;

// Memory protection flags
int PROT_NONE = 0;
int PROT_READ = 1;
int PROT_WRITE = 2;
int PROT_EXEC = 4;

// Memory mapping flags
int MAP_SHARED = 1;
int MAP_PRIVATE = 2;
int MAP_FIXED = 16;
int MAP_ANONYMOUS = 32;

// GC configuration
int GC_DEFAULT_THRESHOLD = 1048576;  // 1MB
int GC_GROW_FACTOR = 2;
int GC_MIN_THRESHOLD = 65536;  // 64KB

// Arena configuration
int ARENA_DEFAULT_CAPACITY = 4096;  // 4KB
int ARENA_DEFAULT_ALIGNMENT = 16;

// Type IDs for GC
int TYPE_ID_INT = 1;
int TYPE_ID_FLOAT = 2;
int TYPE_ID_BOOL = 3;
int TYPE_ID_BYTE = 4;
int TYPE_ID_STR = 5;
int TYPE_ID_ARRAY = 16;
int TYPE_ID_STRUCT = 32;
int TYPE_ID_GC_WRAPPER = 48;
int TYPE_ID_USER = 64;

// GC header flags
int GC_FLAG_MANAGED = 0x01;
int GC_FLAG_MARKED = 0x02;
int GC_FLAG_ARRAY = 0x04;
int GC_FLAG_FINALIZER = 0x08;

// Error codes
int MEM_OK = 0;
int MEM_ERR_NULL = -1;
int MEM_ERR_OOM = -2;
int MEM_ERR_INVALID = -3;
int MEM_ERR_OVERFLOW = -4;

// =============================================================================
// Memory Statistics
// =============================================================================

struct MemStats {
    total_allocated: int;
    gc_objects: int;
    gc_bytes: int;
    arena_count: int;
    arena_bytes: int;
    collection_count: int;
}

// =============================================================================
// Memory Type - Low-level memory operations
// =============================================================================

struct Memory {
    // Static methods only - no instance data
}

impl Memory {
    // -------------------------------------------------------------------------
    // Core Allocation
    // -------------------------------------------------------------------------
    
    // Allocate memory using mmap
    fn alloc(size: int) -> void* {
        int alloc_size = (size + 15) & ~15;  // Align to 16 bytes
        
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return 0;
        }
        
        return mapped;
    }
    
    // Allocate zeroed memory
    fn alloc_zeroed(size: int) -> void* {
        void* ptr = Memory.alloc(size);
        
        if (ptr != 0) {
            Memory.zero(ptr, size);
        }
        
        return ptr;
    }
    
    // Free memory using munmap
    fn free(ptr: void*, size: int) -> void {
        int alloc_size = (size + 15) & ~15;
        syscall SYS_MUNMAP, ptr, alloc_size, ERRNO;
    }
    
    // -------------------------------------------------------------------------
    // Memory Operations
    // -------------------------------------------------------------------------
    
    // Copy memory
    fn copy(dest: void*, src: void*, n: int) -> void* {
        __memcpy(dest, src, n);
        return dest;
    }
    
    // Move memory (handles overlapping regions)
    fn move(dest: void*, src: void*, n: int) -> void* {
        __memmove(dest, src, n);
        return dest;
    }
    
    // Set memory to value
    fn set(dest: void*, value: int, n: int) -> void* {
        __memset(dest, value, n);
        return dest;
    }
    
    // Zero memory
    fn zero(dest: void*, n: int) -> void* {
        __memzero(dest, n);
        return dest;
    }
    
    // Compare memory
    fn compare(s1: void*, s2: void*, n: int) -> int {
        return __memcmp(s1, s2, n);
    }
    
    // Check if memory is zero
    fn is_zero(ptr: void*, n: int) -> bool {
        int i = 0;
        while (i < n) {
            if (((bytes*)ptr)[i] != 0) {
                return false;
            }
            i = i + 1;
        }
        return true;
    }
    
    // -------------------------------------------------------------------------
    // Alignment
    // -------------------------------------------------------------------------
    
    // Align pointer up
    fn align_up(ptr: void*, alignment: int) -> void* {
        int addr = ptr;
        int aligned = (addr + alignment - 1) & ~(alignment - 1);
        return aligned;
    }
    
    // Align pointer down
    fn align_down(ptr: void*, alignment: int) -> void* {
        int addr = ptr;
        int aligned = addr & ~(alignment - 1);
        return aligned;
    }
    
    // Get page size (typically 4096)
    fn page_size() -> int {
        return 4096;
    }
    
    // -------------------------------------------------------------------------
    // Aligned Allocation
    // -------------------------------------------------------------------------
    
    // Allocate aligned memory
    fn alloc_aligned(size: int, alignment: int) -> void* {
        // Allocate extra space for alignment
        int total_size = size + alignment;
        void* raw = Memory.alloc(total_size);
        
        if (raw == 0) {
            return 0;
        }
        
        // Align the pointer
        void* aligned = Memory.align_up(raw + 1, alignment);
        
        // Store the original pointer just before the aligned address
        void** header = aligned - 8;
        *header = raw;
        
        return aligned;
    }
    
    // Free aligned memory
    fn free_aligned(ptr: void*) -> void {
        // Get the original pointer from header
        void** header = ptr - 8;
        void* raw = *header;
        
        // We don't know the exact size, but munmap with the original mapping
        syscall SYS_MUNMAP, raw, 0, ERRNO;
    }
    
    // -------------------------------------------------------------------------
    // Utility
    // -------------------------------------------------------------------------
    
    // Calculate hash of memory region
    fn hash(ptr: void*, len: int) -> int {
        int h = 0;
        int i = 0;
        while (i < len) {
            h = ((h << 5) - h) + ((bytes*)ptr)[i];
            i = i + 1;
        }
        return h;
    }
    
    // Find byte in memory
    fn find_byte(ptr: void*, len: int, value: int) -> int {
        int i = 0;
        while (i < len) {
            if (((bytes*)ptr)[i] == value) {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }
}

// =============================================================================
// Allocator Trait - Interface for custom allocators
// =============================================================================

struct Allocator {
    // Function pointers for allocator interface
    alloc_fn: fn(void*, int) -> void*;
    dealloc_fn: fn(void*, void*) -> void;
    ctx: void*;
}

impl Allocator {
    // Create allocator from functions
    constructor(alloc_fn: fn(void*, int) -> void*, dealloc_fn: fn(void*, void*) -> void, ctx: void*) {
        self.alloc_fn = alloc_fn;
        self.dealloc_fn = dealloc_fn;
        self.ctx = ctx;
    }
    
    // Allocate memory
    fn alloc(self, size: int) -> void* {
        return self.alloc_fn(self.ctx, size);
    }
    
    // Deallocate memory
    fn dealloc(self, ptr: void*) -> void {
        self.dealloc_fn(self.ctx, ptr);
    }
    
    // Create a heap allocator
    fn heap() -> Allocator* {
        return new Allocator(Allocator._heap_alloc, Allocator._heap_dealloc, 0);
    }
    
    // Heap allocation function
    fn _heap_alloc(ctx: void*, size: int) -> void* {
        return Memory.alloc(size);
    }
    
    // Heap deallocation function
    fn _heap_dealloc(ctx: void*, ptr: void*) -> void {
        // Note: We don't know the size here, so this is a no-op for mmap
        // In a real implementation, we'd track sizes
    }
}

// =============================================================================
// GC Object Header
// =============================================================================

struct GCObjectHeader {
    type_id: int;          // Type identifier for tracing
    flags: int;            // GC flags (managed, marked, etc.)
    size: int;             // Payload size
    next: GCObjectHeader*; // Next object in allocation list
    finalizer: fn(void*) -> void;  // Optional finalizer
}

// =============================================================================
// GC Type - Mark-sweep garbage collector
// =============================================================================

struct GC {
    objects: GCObjectHeader*;  // List of all allocated objects
    count: int;                // Number of objects
    total_size: int;           // Total bytes allocated
    threshold: int;            // Collection threshold
    paused: bool;              // GC paused state
    collections: int;          // Number of collections performed
}

impl GC {
    // -------------------------------------------------------------------------
    // Initialization
    // -------------------------------------------------------------------------
    
    // Initialize GC with default threshold
    constructor() {
        self.objects = 0;
        self.count = 0;
        self.total_size = 0;
        self.threshold = GC_DEFAULT_THRESHOLD;
        self.paused = false;
        self.collections = 0;
    }
    
    // Create new GC instance
    fn new() -> GC* {
        GC* gc = __gc_alloc(sizeof(GC), TYPE_ID_STRUCT, 8);
        gc.objects = 0;
        gc.count = 0;
        gc.total_size = 0;
        gc.threshold = GC_DEFAULT_THRESHOLD;
        gc.paused = false;
        gc.collections = 0;
        return gc;
    }
    
    // Create GC with custom threshold
    fn with_threshold(threshold: int) -> GC* {
        GC* gc = GC.new();
        gc.threshold = threshold;
        return gc;
    }
    
    // -------------------------------------------------------------------------
    // Core Allocation
    // -------------------------------------------------------------------------
    
    // Allocate an object with type info
    fn alloc(self, size: int, type_id: int) -> void* {
        return self.alloc_aligned(size, type_id, 8);
    }
    
    // Allocate aligned object
    fn alloc_aligned(self, size: int, type_id: int, alignment: int) -> void* {
        // Check if collection needed
        if (!self.paused && self.total_size > self.threshold) {
            self.collect();
        }
        
        // Use intrinsic for allocation
        void* ptr = __gc_alloc(size, type_id, alignment);
        
        if (ptr == 0) {
            return 0;
        }
        
        // Track in our list (simplified - real GC would use the header)
        self.count = self.count + 1;
        self.total_size = self.total_size + size + 16;  // payload + header
        
        return ptr;
    }
    
    // Allocate typed object
    fn alloc_typed<T>(self) -> T* {
        return self.alloc(sizeof(T), TYPE_ID_USER);
    }
    
    // Allocate array
    fn alloc_array<T>(self, count: int) -> T* {
        int size = sizeof(T) * count;
        T* arr = self.alloc(size, TYPE_ID_ARRAY | TYPE_ID_USER);
        // Could store element count in header for tracing
        return arr;
    }
    
    // -------------------------------------------------------------------------
    // Mark Phase
    // -------------------------------------------------------------------------
    
    // Mark an object as reachable
    fn mark(self, ptr: void*) -> void {
        if (ptr == 0) {
            return;
        }
        __gc_mark(ptr);
    }
    
    // Mark multiple objects
    fn mark_many(self, ptrs: void**, count: int) -> void {
        int i = 0;
        while (i < count) {
            self.mark(ptrs[i]);
            i = i + 1;
        }
    }
    
    // -------------------------------------------------------------------------
    // Sweep and Collection
    // -------------------------------------------------------------------------
    
    // Sweep unmarked objects
    fn sweep(self) -> int {
        int freed = 0;
        
        // Use the intrinsic-based collection
        freed = __gc_collect();
        
        if (freed > 0) {
            self.count = self.count - freed;
            // Adjust total_size estimate
        }
        
        return freed;
    }
    
    // Run garbage collection
    fn collect(self) -> int {
        self.collections = self.collections + 1;
        int freed = self.sweep();
        
        // Adjust threshold
        if (self.total_size < self.threshold / GC_GROW_FACTOR) {
            self.threshold = self.threshold / GC_GROW_FACTOR;
            if (self.threshold < GC_MIN_THRESHOLD) {
                self.threshold = GC_MIN_THRESHOLD;
            }
        } else if (self.total_size > self.threshold) {
            self.threshold = self.total_size * GC_GROW_FACTOR;
        }
        
        return freed;
    }
    
    // Force full collection
    fn collect_full(self) -> int {
        // Multiple collection passes
        int total_freed = 0;
        int freed;
        
        freed = self.collect();
        total_freed = total_freed + freed;
        
        while (freed > 0) {
            freed = self.collect();
            total_freed = total_freed + freed;
        }
        
        return total_freed;
    }
    
    // -------------------------------------------------------------------------
    // Control
    // -------------------------------------------------------------------------
    
    // Pause GC
    fn pause(self) -> void {
        self.paused = true;
    }
    
    // Resume GC
    fn resume(self) -> void {
        self.paused = false;
    }
    
    // Check if paused
    fn is_paused(self) -> bool {
        return self.paused;
    }
    
    // -------------------------------------------------------------------------
    // Statistics
    // -------------------------------------------------------------------------
    
    fn get_count(self) -> int {
        return self.count;
    }
    
    fn get_size(self) -> int {
        return self.total_size;
    }
    
    fn get_threshold(self) -> int {
        return self.threshold;
    }
    
    fn get_collections(self) -> int {
        return self.collections;
    }
    
    fn set_threshold(self, threshold: int) -> void {
        self.threshold = threshold;
    }
    
    // Get statistics struct
    fn stats(self) -> MemStats {
        MemStats s;
        s.total_allocated = self.total_size;
        s.gc_objects = self.count;
        s.gc_bytes = self.total_size;
        s.arena_count = 0;
        s.arena_bytes = 0;
        s.collection_count = self.collections;
        return s;
    }
    
    // -------------------------------------------------------------------------
    // Finalizers
    // -------------------------------------------------------------------------
    
    // Register finalizer for an object
    fn set_finalizer(self, ptr: void*, finalizer: fn(void*) -> void) -> void {
        GCObjectHeader* header = __gc_get_header(ptr);
        header.finalizer = finalizer;
        header.flags = header.flags | GC_FLAG_FINALIZER;
    }
}

// =============================================================================
// GCRef Type - GC-managed reference
// =============================================================================

struct GCRef<T> {
    gc: GC*;
    ptr: T*;
}

impl GCRef<T> {
    constructor(gc: GC*, ptr: T*) {
        self.gc = gc;
        self.ptr = ptr;
    }
    
    // Get raw pointer
    fn get(self) -> T* {
        return self.ptr;
    }
    
    // Dereference
    fn deref(self) -> T {
        return *self.ptr;
    }
    
    // Check validity
    fn is_valid(self) -> bool {
        return self.gc != 0 && self.ptr != 0;
    }
    
    // Mark as reachable
    fn mark(self) -> void {
        if self.gc != 0 && self.ptr != 0 {
            self.gc.mark(self.ptr);
        }
    }
    
    // Get reference to field
    fn field<F>(self, offset: int) -> GCRef<F> {
        return GCRef<F>(self.gc, (F*)(self.ptr + offset));
    }
}

// =============================================================================
// Arena Type - Bump allocator
// =============================================================================

struct Arena {
    base: void*;       // Base address of allocated memory
    offset: int;       // Current offset from base
    capacity: int;     // Total capacity
    growable: bool;    // Whether arena can grow
    id: int;           // Unique arena ID for safety
}

// Global arena ID counter
int ARENA_ID_COUNTER = 0;

impl Arena {
    // -------------------------------------------------------------------------
    // Initialization
    // -------------------------------------------------------------------------
    
    // Create a new arena with default capacity
    constructor() {
        self.base = __arena_new(ARENA_DEFAULT_CAPACITY);
        self.offset = 0;
        self.capacity = ARENA_DEFAULT_CAPACITY;
        self.growable = true;
        ARENA_ID_COUNTER = ARENA_ID_COUNTER + 1;
        self.id = ARENA_ID_COUNTER;
    }
    
    // Create arena with specific capacity
    fn with_capacity(capacity: int) -> Arena* {
        Arena* arena = __arena_new(capacity);
        arena.capacity = capacity;
        arena.growable = false;
        ARENA_ID_COUNTER = ARENA_ID_COUNTER + 1;
        arena.id = ARENA_ID_COUNTER;
        return arena;
    }
    
    // Create growable arena
    fn growable(initial_capacity: int) -> Arena* {
        Arena* arena = __arena_new(initial_capacity);
        arena.capacity = initial_capacity;
        arena.growable = true;
        ARENA_ID_COUNTER = ARENA_ID_COUNTER + 1;
        arena.id = ARENA_ID_COUNTER;
        return arena;
    }
    
    // -------------------------------------------------------------------------
    // Core Allocation
    // -------------------------------------------------------------------------
    
    // Allocate from arena
    fn alloc(self, size: int) -> void* {
        return __arena_alloc(self, size, 8);
    }
    
    // Allocate aligned from arena
    fn alloc_aligned(self, size: int, alignment: int) -> void* {
        return __arena_alloc(self, size, alignment);
    }
    
    // Allocate typed object
    fn alloc_typed<T>(self) -> T* {
        return self.alloc_aligned(sizeof(T), alignof(T));
    }
    
    // Allocate array
    fn alloc_array<T>(self, count: int) -> T* {
        int size = sizeof(T) * count;
        return self.alloc_aligned(size, alignof(T));
    }
    
    // Allocate zeroed memory
    fn alloc_zeroed(self, size: int) -> void* {
        void* ptr = self.alloc(size);
        if (ptr != 0) {
            Memory.zero(ptr, size);
        }
        return ptr;
    }
    
    // -------------------------------------------------------------------------
    // Type-Safe Allocation with ArenaRef
    // -------------------------------------------------------------------------
    
    // Allocate and return ArenaRef
    fn make_ref<T>(self) -> ArenaRef<T> {
        T* ptr = self.alloc_typed<T>();
        return ArenaRef<T>(self, ptr);
    }
    
    // Allocate array and return ArenaRef
    fn make_array_ref<T>(self, count: int) -> ArenaRef<T> {
        T* ptr = self.alloc_array<T>(count);
        return ArenaRef<T>(self, ptr);
    }
    
    // Allocate with initialization
    fn make<T>(self, init: fn(T*) -> void) -> ArenaRef<T> {
        T* ptr = self.alloc_typed<T>();
        if (ptr != 0) {
            init(ptr);
        }
        return ArenaRef<T>(self, ptr);
    }
    
    // -------------------------------------------------------------------------
    // Memory Management
    // -------------------------------------------------------------------------
    
    // Reset arena (keep memory, reset offset)
    fn reset(self) -> void {
        __arena_reset(self);
    }
    
    // Free arena
    fn free(self) -> void {
        __arena_free(self);
        self.base = 0;
        self.offset = 0;
        self.capacity = 0;
    }
    
    // -------------------------------------------------------------------------
    // Save/Restore Points
    // -------------------------------------------------------------------------
    
    // Create a save point
    fn save_point(self) -> int {
        return self.offset;
    }
    
    // Restore to save point
    fn restore(self, save_point: int) -> void {
        if (save_point >= 0 && save_point <= self.offset) {
            self.offset = save_point;
        }
    }
    
    // -------------------------------------------------------------------------
    // Statistics
    // -------------------------------------------------------------------------
    
    fn used(self) -> int {
        return self.offset;
    }
    
    fn available(self) -> int {
        return self.capacity - self.offset;
    }
    
    fn capacity(self) -> int {
        return self.capacity;
    }
    
    fn is_empty(self) -> bool {
        return self.offset == 0;
    }
    
    fn utilization(self) -> float {
        if (self.capacity == 0) {
            return 0.0;
        }
        return self.offset as float / self.capacity as float;
    }
}

// =============================================================================
// ArenaRef Type - Reference to arena-allocated object
// =============================================================================

struct ArenaRef<T> {
    arena: Arena*;
    ptr: T*;
}

impl ArenaRef<T> {
    constructor(arena: Arena*, ptr: T*) {
        self.arena = arena;
        self.ptr = ptr;
    }
    
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    
    fn get(self) -> T* {
        return self.ptr;
    }
    
    fn deref(self) -> T {
        return *self.ptr;
    }
    
    fn is_valid(self) -> bool {
        return self.arena != 0 && self.ptr != 0;
    }
    
    // Get arena ID for safety checks
    fn arena_id(self) -> int {
        if (self.arena != 0) {
            return self.arena.id;
        }
        return 0;
    }
    
    // -------------------------------------------------------------------------
    // Field Access
    // -------------------------------------------------------------------------
    
    // Get reference to field
    fn field<F>(self, offset: int) -> ArenaRef<F> {
        return ArenaRef<F>(self.arena, (F*)(self.ptr + offset));
    }
    
    // -------------------------------------------------------------------------
    // Promotion to GCRef
    // -------------------------------------------------------------------------
    
    // Promote arena allocation to GC-managed memory
    // This copies the object to GC memory and returns a GCRef
    fn promote(self, gc: GC*) -> GCRef<T> {
        if (self.ptr == 0) {
            return GCRef<T>(gc, 0);
        }
        
        // Allocate in GC
        T* gc_ptr = gc.alloc_typed<T>();
        
        if (gc_ptr == 0) {
            return GCRef<T>(gc, 0);
        }
        
        // Copy data
        Memory.copy(gc_ptr, self.ptr, sizeof(T));
        
        return GCRef<T>(gc, gc_ptr);
    }
    
    // Promote with custom copy function
    fn promote_with(self, gc: GC*, copy_fn: fn(T*, T*) -> void) -> GCRef<T> {
        if (self.ptr == 0) {
            return GCRef<T>(gc, 0);
        }
        
        // Allocate in GC
        T* gc_ptr = gc.alloc_typed<T>();
        
        if (gc_ptr == 0) {
            return GCRef<T>(gc, 0);
        }
        
        // Use custom copy
        copy_fn(gc_ptr, self.ptr);
        
        return GCRef<T>(gc, gc_ptr);
    }
    
    // -------------------------------------------------------------------------
    // Safety
    // -------------------------------------------------------------------------
    
    // Check if this reference belongs to a specific arena
    fn belongs_to(self, arena: Arena*) -> bool {
        return self.arena != 0 && self.arena.id == arena.id;
    }
    
    // Validate reference is still in bounds
    fn in_bounds(self) -> bool {
        if (self.arena == 0 || self.ptr == 0) {
            return false;
        }
        
        int offset = self.ptr - self.arena.base;
        return offset >= 0 && offset < self.arena.offset;
    }
}

// =============================================================================
// Buffer Type - Dynamic byte buffer
// =============================================================================

struct Buffer {
    data: void*;
    length: int;
    capacity: int;
    growable: bool;
}

impl Buffer {
    // -------------------------------------------------------------------------
    // Initialization
    // -------------------------------------------------------------------------
    
    constructor() {
        self.data = 0;
        self.length = 0;
        self.capacity = 0;
        self.growable = true;
    }
    
    fn with_capacity(capacity: int) -> Buffer* {
        Buffer* buf = new Buffer();
        buf.data = Memory.alloc(capacity);
        buf.capacity = capacity;
        buf.length = 0;
        buf.growable = true;
        return buf;
    }
    
    fn from_bytes(data: void*, len: int) -> Buffer* {
        Buffer* buf = Buffer.with_capacity(len);
        Memory.copy(buf.data, data, len);
        buf.length = len;
        return buf;
    }
    
    // Create a fixed-size buffer (non-growable)
    fn fixed(capacity: int) -> Buffer* {
        Buffer* buf = Buffer.with_capacity(capacity);
        buf.growable = false;
        return buf;
    }
    
    // -------------------------------------------------------------------------
    // Properties
    // -------------------------------------------------------------------------
    
    fn len(self) -> int {
        return self.length;
    }
    
    fn capacity(self) -> int {
        return self.capacity;
    }
    
    fn is_empty(self) -> bool {
        return self.length == 0;
    }
    
    fn is_full(self) -> bool {
        return self.length >= self.capacity;
    }
    
    fn remaining(self) -> int {
        return self.capacity - self.length;
    }
    
    // -------------------------------------------------------------------------
    // Element Access
    // -------------------------------------------------------------------------
    
    fn get(self, index: int) -> int {
        if (index < 0 || index >= self.length) {
            return -1;
        }
        return ((bytes*)self.data)[index];
    }
    
    fn set(self, index: int, value: int) -> void {
        if (index >= 0 && index < self.length) {
            ((bytes*)self.data)[index] = value;
        }
    }
    
    // Get as pointer
    fn as_ptr(self) -> void* {
        return self.data;
    }
    
    // Get slice as pointer
    fn slice(self, start: int, len: int) -> void* {
        if (start < 0 || start + len > self.length) {
            return 0;
        }
        return self.data + start;
    }
    
    // Get as typed pointer
    fn as_typed<T>(self) -> T* {
        return (T*)self.data;
    }
    
    // -------------------------------------------------------------------------
    // Modification
    // -------------------------------------------------------------------------
    
    fn push(self, byte: int) -> void {
        if (self.length >= self.capacity) {
            if (self.growable) {
                self._grow(self.capacity == 0 ? 16 : self.capacity * 2);
            } else {
                return;  // Cannot grow
            }
        }
        
        ((bytes*)self.data)[self.length] = byte;
        self.length = self.length + 1;
    }
    
    fn pop(self) -> int {
        if (self.length == 0) {
            return -1;
        }
        
        self.length = self.length - 1;
        return ((bytes*)self.data)[self.length];
    }
    
    fn append(self, data: void*, len: int) -> void {
        // Ensure capacity
        while (self.length + len > self.capacity) {
            if (self.growable) {
                self._grow(self.capacity * 2);
            } else {
                return;  // Cannot grow
            }
        }
        
        Memory.copy(self.data + self.length, data, len);
        self.length = self.length + len;
    }
    
    fn append_buffer(self, other: Buffer*) -> void {
        self.append(other.data, other.length);
    }
    
    fn clear(self) -> void {
        self.length = 0;
    }
    
    fn truncate(self, len: int) -> void {
        if (len >= 0 && len < self.length) {
            self.length = len;
        }
    }
    
    // -------------------------------------------------------------------------
    // Search
    // -------------------------------------------------------------------------
    
    fn find(self, byte: int) -> int {
        int i = 0;
        while (i < self.length) {
            if (((bytes*)self.data)[i] == byte) {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }
    
    fn find_slice(self, needle: void*, len: int) -> int {
        if (len > self.length) {
            return -1;
        }
        
        int i = 0;
        while (i <= self.length - len) {
            if (Memory.compare(self.data + i, needle, len) == 0) {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }
    
    fn count(self, byte: int) -> int {
        int count = 0;
        int i = 0;
        while (i < self.length) {
            if (((bytes*)self.data)[i] == byte) {
                count = count + 1;
            }
            i = i + 1;
        }
        return count;
    }
    
    // -------------------------------------------------------------------------
    // Transformation
    // -------------------------------------------------------------------------
    
    fn reverse(self) -> void {
        int i = 0;
        int j = self.length - 1;
        while (i < j) {
            int tmp = ((bytes*)self.data)[i];
            ((bytes*)self.data)[i] = ((bytes*)self.data)[j];
            ((bytes*)self.data)[j] = tmp;
            i = i + 1;
            j = j - 1;
        }
    }
    
    fn fill(self, value: int) -> void {
        Memory.set(self.data, value, self.length);
    }
    
    fn fill_range(self, start: int, len: int, value: int) -> void {
        if (start < 0 || start + len > self.length) {
            return;
        }
        Memory.set(self.data + start, value, len);
    }
    
    // -------------------------------------------------------------------------
    // Comparison
    // -------------------------------------------------------------------------
    
    fn equals(self, other: Buffer*) -> bool {
        if (self.length != other.length) {
            return false;
        }
        return Memory.compare(self.data, other.data, self.length) == 0;
    }
    
    fn equals_bytes(self, data: void*, len: int) -> bool {
        if (self.length != len) {
            return false;
        }
        return Memory.compare(self.data, data, len) == 0;
    }
    
    // -------------------------------------------------------------------------
    // Growth
    // -------------------------------------------------------------------------
    
    fn reserve(self, additional: int) -> void {
        if (self.length + additional > self.capacity) {
            self._grow(self.length + additional);
        }
    }
    
    fn resize(self, new_len: int) -> void {
        if (new_len > self.capacity) {
            if self.growable {
                self._grow(new_len);
            } else {
                return;
            }
        }
        self.length = new_len;
    }
    
    fn _grow(self, new_capacity: int) -> void {
        void* new_data = Memory.alloc(new_capacity);
        
        if (self.data != 0) {
            Memory.copy(new_data, self.data, self.length);
            Memory.free(self.data, self.capacity);
        }
        
        self.data = new_data;
        self.capacity = new_capacity;
    }
    
    // -------------------------------------------------------------------------
    // Memory Management
    // -------------------------------------------------------------------------
    
    fn free(self) -> void {
        if (self.data != 0) {
            Memory.free(self.data, self.capacity);
            self.data = 0;
            self.length = 0;
            self.capacity = 0;
        }
    }
    
    // Transfer ownership (returns data pointer, clears buffer)
    fn into_ptr(self) -> void* {
        void* ptr = self.data;
        self.data = 0;
        self.length = 0;
        self.capacity = 0;
        return ptr;
    }
    
    // Clone buffer
    fn clone(self) -> Buffer* {
        Buffer* copy = Buffer.with_capacity(self.length);
        Memory.copy(copy.data, self.data, self.length);
        copy.length = self.length;
        return copy;
    }
    
    // -------------------------------------------------------------------------
    // I/O Helpers
    // -------------------------------------------------------------------------
    
    // Write integer as little-endian
    fn write_u32_le(self, value: int, offset: int) -> void {
        if (offset + 4 > self.length) {
            return;
        }
        ((int*)self.data)[offset / 4] = value;
    }
    
    // Read integer as little-endian
    fn read_u32_le(self, offset: int) -> int {
        if (offset + 4 > self.length) {
            return 0;
        }
        return ((int*)self.data)[offset / 4];
    }
    
    // Write byte string
    fn write_str(self, str: bytes*, len: int) -> int {
        if (self.length + len > self.capacity) {
            if self.growable {
                self._grow(self.length + len);
            } else {
                return -1;
            }
        }
        Memory.copy(self.data + self.length, str, len);
        self.length = self.length + len;
        return self.length - len;  // Return offset where written
    }
}

// =============================================================================
// Pool Type - Object pool for fixed-size objects
// =============================================================================

struct Pool {
    object_size: int;
    capacity: int;
    count: int;
    free_list: void*;
    memory: void*;
}

impl Pool {
    constructor(object_size: int, capacity: int) {
        self.object_size = object_size;
        self.capacity = capacity;
        self.count = 0;
        
        // Allocate memory for all objects
        int total_size = object_size * capacity;
        self.memory = Memory.alloc(total_size);
        
        // Build free list
        self.free_list = 0;
        int i = 0;
        while (i < capacity) {
            void* obj = self.memory + i * object_size;
            
            // Link to free list
            void** link = obj;
            *link = self.free_list;
            self.free_list = obj;
            
            i = i + 1;
        }
    }
    
    // Allocate from pool
    fn alloc(self) -> void* {
        if (self.free_list == 0) {
            return 0;  // Pool exhausted
        }
        
        void* obj = self.free_list;
        void** link = obj;
        self.free_list = *link;
        self.count = self.count + 1;
        
        return obj;
    }
    
    // Allocate typed
    fn alloc_typed<T>(self) -> T* {
        return (T*)self.alloc();
    }
    
    // Return to pool
    fn free(self, obj: void*) -> void {
        void** link = obj;
        *link = self.free_list;
        self.free_list = obj;
        self.count = self.count - 1;
    }
    
    // Get statistics
    fn available(self) -> int {
        return self.capacity - self.count;
    }
    
    fn used(self) -> int {
        return self.count;
    }
    
    fn is_full(self) -> bool {
        return self.free_list == 0;
    }
    
    fn is_empty(self) -> bool {
        return self.count == 0;
    }
    
    fn utilization(self) -> float {
        if (self.capacity == 0) {
            return 0.0;
        }
        return self.count as float / self.capacity as float;
    }
    
    // Destroy pool
    fn destroy(self) -> void {
        if (self.memory != 0) {
            Memory.free(self.memory, self.object_size * self.capacity);
            self.memory = 0;
            self.free_list = 0;
        }
    }
}

// =============================================================================
// Global GC Instance (Thread-Local)
// =============================================================================

// Thread-local GC instance
GC* __global_gc = 0;

// Get or create global GC
fn get_gc() -> GC* {
    if (__global_gc == 0) {
        __global_gc = GC.new();
    }
    return __global_gc;
}

// Convenience allocation
fn gc_alloc(size: int, type_id: int) -> void* {
    return get_gc().alloc(size, type_id);
}

fn gc_alloc_typed<T>() -> T* {
    return get_gc().alloc_typed<T>();
}
