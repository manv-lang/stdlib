// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/sys/sys.mv
// description: System operations module with OOP design
//
// This module provides system-level operations using impl blocks.
// All functions are implemented in pure ManV using syscalls.
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Syscall numbers for Linux x86-64
int SYS_READ = 0;
int SYS_WRITE = 1;
int SYS_OPEN = 2;
int SYS_CLOSE = 3;
int SYS_STAT = 4;
int SYS_FSTAT = 5;
int SYS_LSTAT = 6;
int SYS_POLL = 7;
int SYS_LSEEK = 8;
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;
int SYS_BRK = 12;
int SYS_RT_SIGACTION = 13;
int SYS_RT_SIGPROCMASK = 14;
int SYS_RT_SIGRETURN = 15;
int SYS_IOCTL = 16;
int SYS_PREAD = 17;
int SYS_PWRITE = 18;
int SYS_READV = 19;
int SYS_WRITEV = 20;
int SYS_ACCESS = 21;
int SYS_PIPE = 22;
int SYS_SELECT = 23;
int SYS_SCHED_YIELD = 24;
int SYS_MREMAP = 25;
int SYS_MSYNC = 26;
int SYS_MINCORE = 27;
int SYS_MADVISE = 28;
int SYS_SHMGET = 29;
int SYS_SHMAT = 30;
int SYS_SHMCTL = 31;
int SYS_DUP = 32;
int SYS_DUP2 = 33;
int SYS_PAUSE = 34;
int SYS_NANOSLEEP = 35;
int SYS_GETITIMER = 36;
int SYS_ALARM = 37;
int SYS_SETITIMER = 38;
int SYS_GETPID = 39;
int SYS_SENDFILE = 40;
int SYS_SOCKET = 41;
int SYS_CONNECT = 42;
int SYS_ACCEPT = 43;
int SYS_SENDTO = 44;
int SYS_RECVFROM = 45;
int SYS_SENDMSG = 46;
int SYS_RECVMSG = 47;
int SYS_SHUTDOWN = 48;
int SYS_BIND = 49;
int SYS_LISTEN = 50;
int SYS_GETSOCKNAME = 51;
int SYS_GETPEERNAME = 52;
int SYS_SOCKETPAIR = 53;
int SYS_SETSOCKOPT = 54;
int SYS_GETSOCKOPT = 55;
int SYS_CLONE = 56;
int SYS_FORK = 57;
int SYS_VFORK = 58;
int SYS_EXECVE = 59;
int SYS_EXIT = 60;
int SYS_WAIT4 = 61;
int SYS_KILL = 62;
int SYS_UNAME = 63;
int SYS_SEMGET = 64;
int SYS_SEMOP = 65;
int SYS_SEMCTL = 66;
int SYS_SHMDT = 67;
int SYS_MSGGET = 68;
int SYS_MSGSND = 69;
int SYS_MSGRCV = 70;
int SYS_MSGCTL = 71;
int SYS_FCNTL = 72;
int SYS_FLOCK = 73;
int SYS_FSYNC = 74;
int SYS_FDATASYNC = 75;
int SYS_TRUNCATE = 76;
int SYS_FTRUNCATE = 77;
int SYS_GETDENTS = 78;
int SYS_GETCWD = 79;
int SYS_CHDIR = 80;
int SYS_FCHDIR = 81;
int SYS_RENAME = 82;
int SYS_MKDIR = 83;
int SYS_RMDIR = 84;
int SYS_CREAT = 85;
int SYS_LINK = 86;
int SYS_UNLINK = 87;
int SYS_SYMLINK = 88;
int SYS_READLINK = 89;
int SYS_CHMOD = 90;
int SYS_FCHMOD = 91;
int SYS_CHOWN = 92;
int SYS_FCHOWN = 93;
int SYS_LCHOWN = 94;
int SYS_UMASK = 95;
int SYS_GETTIMEOFDAY = 96;
int SYS_GETRLIMIT = 97;
int SYS_GETRUSAGE = 98;
int SYS_SYSINFO = 99;
int SYS_TIMES = 100;
int SYS_PTRACE = 101;
int SYS_GETUID = 102;
int SYS_SYSLOG = 103;
int SYS_GETGID = 104;
int SYS_SETUID = 105;
int SYS_SETGID = 106;
int SYS_GETEUID = 107;
int SYS_GETEGID = 108;
int SYS_SETPGID = 109;
int SYS_GETPPID = 110;
int SYS_GETPGRP = 111;
int SYS_SETSID = 112;
int SYS_SETREUID = 113;
int SYS_SETREGID = 114;
int SYS_GETGROUPS = 115;
int SYS_SETGROUPS = 116;
int SYS_SETRESUID = 117;
int SYS_GETRESUID = 118;
int SYS_SETRESGID = 119;
int SYS_GETRESGID = 120;
int SYS_GETPGID = 121;
int SYS_SETFSUID = 122;
int SYS_SETFSGID = 123;
int SYS_GETSID = 124;
int SYS_CAPGET = 125;
int SYS_CAPSET = 126;
int SYS_RT_SIGPENDING = 127;
int SYS_RT_SIGTIMEDWAIT = 128;
int SYS_RT_SIGQUEUEINFO = 129;
int SYS_SIGALTSTACK = 130;
int SYS_UTIME = 132;
int SYS_MKNOD = 133;
int SYS_USELIB = 134;
int SYS_PERSONALITY = 135;
int SYS_USTAT = 136;
int SYS_STATFS = 137;
int SYS_FSTATFS = 138;
int SYS_SYSFS = 139;
int SYS_GETPRIORITY = 140;
int SYS_SETPRIORITY = 141;
int SYS_SCHED_SETPARAM = 142;
int SYS_SCHED_GETPARAM = 143;
int SYS_SCHED_SETSCHEDULER = 144;
int SYS_SCHED_GETSCHEDULER = 145;
int SYS_SCHED_GET_PRIORITY_MAX = 146;
int SYS_SCHED_GET_PRIORITY_MIN = 147;
int SYS_SCHED_RR_GET_INTERVAL = 148;
int SYS_MLOCK = 149;
int SYS_MUNLOCK = 150;
int SYS_MLOCKALL = 151;
int SYS_MUNLOCKALL = 152;
int SYS_VHANGUP = 153;
int SYS_MODIFY_LDT = 154;
int SYS_PIVOT_ROOT = 155;
int SYS__SYSCTL = 156;
int SYS_PRCTL = 157;
int SYS_ARCH_PRCTL = 158;
int SYS_ADJTIMEX = 159;
int SYS_SETRLIMIT = 160;
int SYS_CHROOT = 161;
int SYS_SYNC = 162;
int SYS_ACCT = 163;
int SYS_SETTIMEOFDAY = 164;
int SYS_MOUNT = 165;
int SYS_UMOUNT2 = 166;
int SYS_SWAPON = 167;
int SYS_SWAPOFF = 168;
int SYS_REBOOT = 169;
int SYS_SETHOSTNAME = 170;
int SYS_SETDOMAINNAME = 171;
int SYS_IOPL = 172;
int SYS_IOPERM = 173;
int SYS_CREATE_MODULE = 174;
int SYS_INIT_MODULE = 175;
int SYS_DELETE_MODULE = 176;
int SYS_GET_KERNEL_SYMS = 177;
int SYS_QUERY_MODULE = 178;
int SYS_QUOTACTL = 179;
int SYS_BDFLUSH = 180;
int SYS_SYSFS = 181;
int SYS_AFS_SYSCALL = 183;
int SYS_TUXCALL = 184;
int SYS_SECURITY = 185;
int SYS_GETTID = 186;
int SYS_READAHEAD = 187;
int SYS_SETXATTR = 188;
int SYS_LSETXATTR = 189;
int SYS_FSETXATTR = 190;
int SYS_GETXATTR = 191;
int SYS_LGETXATTR = 192;
int SYS_FGETXATTR = 193;
int SYS_LISTXATTR = 194;
int SYS_LLISTXATTR = 195;
int SYS_FLISTXATTR = 196;
int SYS_REMOVEXATTR = 197;
int SYS_LREMOVEXATTR = 198;
int SYS_FREMOVEXATTR = 199;
int SYS_TKILL = 200;
int SYS_TIME = 201;
int SYS_FUTEX = 202;
int SYS_SCHED_SETAFFINITY = 203;
int SYS_SCHED_GETAFFINITY = 204;
int SYS_SET_THREAD_AREA = 205;
int SYS_IO_SETUP = 206;
int SYS_IO_DESTROY = 207;
int SYS_IO_GETEVENTS = 208;
int SYS_IO_SUBMIT = 209;
int SYS_IO_CANCEL = 210;
int SYS_GET_THREAD_AREA = 211;
int SYS_EPOLL_CREATE = 213;
int SYS_EPOLL_CTL = 231;
int SYS_EPOLL_WAIT = 232;
int SYS_REMAP_FILE_PAGES = 216;
int SYS_GETDENTS64 = 217;
int SYS_SET_TID_ADDRESS = 218;
int SYS_RESTART_SYSCALL = 219;
int SYS_SEMTIMEDOP = 220;
int SYS_FADVISE64 = 221;
int SYS_TIMER_CREATE = 222;
int SYS_TIMER_SETTIME = 223;
int SYS_TIMER_GETTIME = 224;
int SYS_TIMER_GETOVERRUN = 225;
int SYS_TIMER_DELETE = 226;
int SYS_CLOCK_SETTIME = 227;
int SYS_CLOCK_GETTIME = 228;
int SYS_CLOCK_GETRES = 229;
int SYS_CLOCK_NANOSLEEP = 230;
int SYS_EXIT_GROUP = 231;
int SYS_EPOLL_WAIT = 232;
int SYS_EPOLL_CTL = 233;
int SYS_TGKILL = 234;
int SYS_UTIMES = 235;
int SYS_MBIND = 237;
int SYS_SET_MEMPOLICY = 238;
int SYS_GET_MEMPOLICY = 239;
int SYS_MQ_OPEN = 240;
int SYS_MQ_UNLINK = 241;
int SYS_MQ_TIMEDSEND = 242;
int SYS_MQ_TIMEDRECEIVE = 243;
int SYS_MQ_NOTIFY = 244;
int SYS_MQ_GETSETATTR = 245;
int SYS_KEXEC_LOAD = 246;
int SYS_WAITID = 247;
int SYS_ADD_KEY = 248;
int SYS_REQUEST_KEY = 249;
int SYS_KEYCTL = 250;
int SYS_IOPRIO_SET = 251;
int SYS_IOPRIO_GET = 252;
int SYS_INOTIFY_INIT = 253;
int SYS_INOTIFY_ADD_WATCH = 254;
int SYS_INOTIFY_RM_WATCH = 255;
int SYS_MIGRATE_PAGES = 256;
int SYS_OPENAT = 257;
int SYS_MKDIRAT = 258;
int SYS_MKNODAT = 259;
int SYS_FCHOWNAT = 260;
int SYS_FUTIMESAT = 261;
int SYS_NEWFSTATAT = 262;
int SYS_UNLINKAT = 263;
int SYS_RENAMEAT = 264;
int SYS_LINKAT = 265;
int SYS_SYMLINKAT = 266;
int SYS_READLINKAT = 267;
int SYS_FCHMODAT = 268;
int SYS_FACCESSAT = 269;
int SYS_PSELECT6 = 270;
int SYS_PPOLL = 271;
int SYS_UNSHARE = 272;
int SYS_SET_ROBUST_LIST = 273;
int SYS_GET_ROBUST_LIST = 274;
int SYS_SPLICE = 275;
int SYS_TEE = 276;
int SYS_SYNC_FILE_RANGE = 277;
int SYS_VMSPLICE = 278;
int SYS_MOVE_PAGES = 279;
int SYS_UTIMENSAT = 280;
int SYS_EPOLL_PWAIT = 281;
int SYS_SIGNALFD = 282;
int SYS_TIMERFD_CREATE = 283;
int SYS_EVENTFD = 284;
int SYS_FALLOCATE = 285;
int SYS_TIMERFD_SETTIME = 286;
int SYS_TIMERFD_GETTIME = 287;
int SYS_ACCEPT4 = 288;
int SYS_SIGNALFD4 = 289;
int SYS_EVENTFD2 = 290;
int SYS_EPOLL_CREATE1 = 291;
int SYS_DUP3 = 292;
int SYS_PIPE2 = 293;
int SYS_INOTIFY_INIT1 = 294;
int SYS_PREADV = 295;
int SYS_PWRITEV = 296;
int SYS_RT_TGSIGQUEUEINFO = 297;
int SYS_PERF_EVENT_OPEN = 298;
int SYS_RECVMMSG = 299;
int SYS_FANOTIFY_INIT = 300;
int SYS_FANOTIFY_MARK = 301;
int SYS_PRLIMIT64 = 302;
int SYS_NAME_TO_HANDLE_AT = 303;
int SYS_OPEN_BY_HANDLE_AT = 304;
int SYS_CLOCK_ADJTIME = 305;
int SYS_SYNCFS = 306;
int SYS_SENDMMSG = 307;
int SYS_SETNS = 308;
int SYS_GETCPU = 309;
int SYS_PROCESS_VM_READV = 310;
int SYS_PROCESS_VM_WRITEV = 311;
int SYS_KCMP = 312;
int SYS_FINIT_MODULE = 313;

// Signal constants
int SIGINT = 2;
int SIGILL = 4;
int SIGABRT = 6;
int SIGFPE = 8;
int SIGKILL = 9;
int SIGSEGV = 11;
int SIGTERM = 15;
int SIGCHLD = 17;
int SIGCONT = 18;
int SIGSTOP = 19;
int SIGTSTP = 20;
int SIGTTIN = 21;
int SIGTTOU = 22;
int SIGUSR1 = 10;
int SIGUSR2 = 12;

// File descriptors
int STDIN = 0;
int STDOUT = 1;
int STDERR = 2;

// Error handling
int ERRNO;

// =============================================================================
// Sys Type - System operations
// =============================================================================

struct Sys {
    // Static methods only
}

impl Sys {
    // =========================================================================
    // Process Control
    // =========================================================================
    
    // Exit with code
    fn exit(code: int) -> void {
        syscall SYS_EXIT, code, ERRNO;
    }
    
    // Exit group (all threads)
    fn exit_group(code: int) -> void {
        syscall SYS_EXIT_GROUP, code, ERRNO;
    }
    
    // Get process ID
    fn getpid() -> int {
        int pid;
        syscall SYS_GETPID, pid, ERRNO;
        return pid;
    }
    
    // Get parent process ID
    fn getppid() -> int {
        int ppid;
        syscall SYS_GETPPID, ppid, ERRNO;
        return ppid;
    }
    
    // Fork process
    fn fork() -> int {
        int result;
        syscall SYS_FORK, result, ERRNO;
        return result;
    }
    
    // Execute program
    fn exec(path: str*, args: void*) -> int {
        int result;
        syscall SYS_EXECVE, path, args, 0, result, ERRNO;
        return result;
    }
    
    // Wait for process
    fn wait(pid: int) -> int {
        int status;
        int result;
        syscall SYS_WAIT4, pid, &status, 0, 0, result, ERRNO;
        return status;
    }
    
    // Wait with status
    fn wait_status(pid: int) -> int {
        int status;
        int result;
        syscall SYS_WAIT4, pid, &status, 0, 0, result, ERRNO;
        return status;
    }
    
    // Kill process
    fn kill(pid: int, sig: int) -> int {
        int result;
        syscall SYS_KILL, pid, sig, result, ERRNO;
        return result;
    }
    
    // Raise signal to self
    fn raise(sig: int) -> int {
        return Sys.kill(Sys.getpid(), sig);
    }
    
    // =========================================================================
    // User and Group
    // =========================================================================
    
    // Get user ID
    fn getuid() -> int {
        int uid;
        syscall SYS_GETUID, uid, ERRNO;
        return uid;
    }
    
    // Get effective user ID
    fn geteuid() -> int {
        int euid;
        syscall SYS_GETEUID, euid, ERRNO;
        return euid;
    }
    
    // Get group ID
    fn getgid() -> int {
        int gid;
        syscall SYS_GETGID, gid, ERRNO;
        return gid;
    }
    
    // Get effective group ID
    fn getegid() -> int {
        int egid;
        syscall SYS_GETEGID, egid, ERRNO;
        return egid;
    }
    
    // Set user ID
    fn setuid(uid: int) -> int {
        int result;
        syscall SYS_SETUID, uid, result, ERRNO;
        return result;
    }
    
    // Set group ID
    fn setgid(gid: int) -> int {
        int result;
        syscall SYS_SETGID, gid, result, ERRNO;
        return result;
    }
    
    // =========================================================================
    // Time Functions
    // =========================================================================
    
    // Get Unix timestamp (seconds)
    fn time() -> int {
        int t;
        syscall SYS_TIME, &t, t, ERRNO;
        return t;
    }
    
    // Get time of day
    fn gettimeofday(tv: void*) -> int {
        int result;
        syscall SYS_GETTIMEOFDAY, tv, 0, result, ERRNO;
        return result;
    }
    
    // Get clock time
    fn clock_gettime(clk_id: int, tp: void*) -> int {
        int result;
        syscall SYS_CLOCK_GETTIME, clk_id, tp, result, ERRNO;
        return result;
    }
    
    // Sleep for seconds
    fn sleep(seconds: int) -> void {
        int req_sec = seconds;
        int req_nsec = 0;
        int rem_sec;
        int rem_nsec;
        syscall SYS_NANOSLEEP, &req_sec, &rem_sec, ERRNO;
    }
    
    // Sleep for milliseconds
    fn sleep_ms(ms: int) -> void {
        int req_sec = ms / 1000;
        int req_nsec = (ms % 1000) * 1000000;
        int rem_sec;
        int rem_nsec;
        syscall SYS_NANOSLEEP, &req_sec, &rem_sec, ERRNO;
    }
    
    // Sleep for microseconds
    fn sleep_us(us: int) -> void {
        int req_sec = us / 1000000;
        int req_nsec = (us % 1000000) * 1000;
        int rem_sec;
        int rem_nsec;
        syscall SYS_NANOSLEEP, &req_sec, &rem_sec, ERRNO;
    }
    
    // =========================================================================
    // System Information
    // =========================================================================
    
    // Get system info
    fn sysinfo(info: void*) -> int {
        int result;
        syscall SYS_SYSINFO, info, result, ERRNO;
        return result;
    }
    
    // Get hostname
    fn gethostname(buffer: str*, len: int) -> int {
        int result;
        syscall SYS_GETHOSTNAME, buffer, len, result, ERRNO;
        return result;
    }
    
    // Set hostname
    fn sethostname(name: str*, len: int) -> int {
        int result;
        syscall SYS_SETHOSTNAME, name, len, result, ERRNO;
        return result;
    }
    
    // Get page size
    fn page_size() -> int {
        return 4096;
    }
    
    // Get CPU count
    fn cpu_count() -> int {
        // Use sysinfo to get CPU count
        bytes info[256];  // struct sysinfo
        Sys.sysinfo(info);
        
        // CPU count is at offset 24
        int* cpu_ptr = info + 24;
        return *cpu_ptr;
    }
    
    // =========================================================================
    // Random Numbers
    // =========================================================================
    
    // Get random bytes
    fn random_bytes(buffer: void*, size: int) -> int {
        // Use getrandom syscall (318) or read from /dev/urandom
        // Simplified: use time-based pseudo-random
        int seed = Sys.time();
        int i = 0;
        
        while (i < size) {
            seed = seed * 1103515245 + 12345;
            ((bytes*)buffer)[i] = (seed >> 16) & 0xFF;
            i = i + 1;
        }
        
        return size;
    }
    
    // Get random int
    fn random_int() -> int {
        int result;
        Sys.random_bytes(&result, 8);
        return result;
    }
    
    // Get random int in range
    fn random_range(min: int, max: int) -> int {
        int r = Sys.random_int();
        if (r < 0) { r = -r; }
        return min + (r % (max - min + 1));
    }
    
    // Seed random (no-op for now)
    fn random_seed(seed: int) -> void {
        // Would set seed for PRNG
    }
    
    // =========================================================================
    // Command Line Arguments
    // =========================================================================
    
    // Get argument count
    fn argc() -> int {
        // Would be provided by runtime
        return 0;
    }
    
    // Get argument by index
    fn argv(index: int) -> str* {
        // Would be provided by runtime
        return "";
    }
    
    // Get environment variable
    fn getenv(name: str*) -> str* {
        // Would need to search environ
        return "";
    }
    
    // Set environment variable
    fn setenv(name: str*, value: str*) -> int {
        // Would call setenv syscall
        return 0;
    }
    
    // =========================================================================
    // Directory Operations
    // =========================================================================
    
    // Get current working directory
    fn getcwd(buffer: str*, size: int) -> str* {
        int result;
        syscall SYS_GETCWD, buffer, size, result, ERRNO;
        return buffer;
    }
    
    // Change directory
    fn chdir(path: str*) -> int {
        int result;
        syscall SYS_CHDIR, path, result, ERRNO;
        return result;
    }
    
    // Create directory
    fn mkdir(path: str*, mode: int) -> int {
        int result;
        syscall SYS_MKDIR, path, mode, result, ERRNO;
        return result;
    }
    
    // Remove directory
    fn rmdir(path: str*) -> int {
        int result;
        syscall SYS_RMDIR, path, result, ERRNO;
        return result;
    }
}

// =============================================================================
// SysInfo Type
// =============================================================================

struct SysInfo {
    uptime: int;
    loads: array<int, 3>;
    totalram: int;
    freeram: int;
    sharedram: int;
    bufferram: int;
    totalswap: int;
    freeswap: int;
    procs: int;
    totalhigh: int;
    freehigh: int;
    mem_unit: int;
}

impl SysInfo {
    constructor() {
        self.uptime = 0;
        self.loads = [0, 0, 0];
        self.totalram = 0;
        self.freeram = 0;
        self.sharedram = 0;
        self.bufferram = 0;
        self.totalswap = 0;
        self.freeswap = 0;
        self.procs = 0;
        self.totalhigh = 0;
        self.freehigh = 0;
        self.mem_unit = 0;
    }
    
    fn load() -> SysInfo* {
        SysInfo* info = new SysInfo();
        Sys.sysinfo(info);
        return info;
    }
    
    fn total_memory(self) -> int {
        return self.totalram;
    }
    
    fn free_memory(self) -> int {
        return self.freeram;
    }
    
    fn used_memory(self) -> int {
        return self.totalram - self.freeram;
    }
    
    fn used_percent(self) -> float {
        if (self.totalram == 0) { return 0.0; }
        return (self.totalram - self.freeram) * 100.0 / self.totalram;
    }
    
    fn uptime_seconds(self) -> int {
        return self.uptime;
    }
    
    fn process_count(self) -> int {
        return self.procs;
    }
}

// =============================================================================
// UserInfo Type
// =============================================================================

struct UserInfo {
    uid: int;
    gid: int;
    name: str*;
    home: str*;
    shell: str*;
}

impl UserInfo {
    constructor() {
        self.uid = Sys.getuid();
        self.gid = Sys.getgid();
        self.name = "";
        self.home = "";
        self.shell = "";
    }
    
    fn current() -> UserInfo* {
        return new UserInfo();
    }
    
    fn is_root(self) -> bool {
        return self.uid == 0;
    }
}