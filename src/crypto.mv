// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/crypto/crypto.mv
// description: Cryptographic utilities module with OOP design
//
// Types:
// -------
// - Sha256     - SHA-256 hash
// - Md5        - MD5 hash (legacy)
// - Hmac       - HMAC authentication
// - Random     - Cryptographically secure random
// - Aes256     - AES-256 encryption
//
// Functions:
// ----------
// - sha256(data, len)     - Compute SHA-256 hash
// - md5(data, len)        - Compute MD5 hash
// - hmac_sha256(key, data) - Compute HMAC-SHA256
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

int SYS_GETRANDOM = 318;
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;
int PROT_READ = 1;
int PROT_WRITE = 2;
int MAP_PRIVATE = 2;
int MAP_ANONYMOUS = 32;
int ERRNO;

// SHA-256 initial values
int SHA256_H0 = 0x6a09e667;
int SHA256_H1 = 0xbb67ae85;
int SHA256_H2 = 0x3c6ef372;
int SHA256_H3 = 0xa54ff53a;
int SHA256_H4 = 0x510e527f;
int SHA256_H5 = 0x9b05688c;
int SHA256_H6 = 0x1f83d9ab;
int SHA256_H7 = 0x5be0cd19;

// =============================================================================
// Random Type
// =============================================================================

struct Random {
    seed: int;
}

impl Random {
    constructor() {
        self.seed = 0;
    }
    
    fn new() -> Random* {
        Random* r = new Random();
        r.seed = 0;
        return r;
    }
    
    fn bytes(len: int) -> bytes* {
        int alloc_size = 8 + len;
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return 0;
        }
        
        bytes* output = mapped + 8;
        int ret;
        syscall SYS_GETRANDOM, output, len, 0, ret, ERRNO;
        
        int* len_header = mapped;
        *len_header = len;
        
        return output;
    }
    
    fn int() -> int {
        bytes* buf = Random.bytes(8);
        if (buf == 0) {
            return 0;
        }
        
        int result = 0;
        int i = 0;
        while (i < 8) {
            result = (result << 8) | (buf[i] & 0xFF);
            i = i + 1;
        }
        
        return result;
    }
    
    fn int_range(min: int, max: int) -> int {
        if (min >= max) {
            return min;
        }
        int r = Random.int();
        return min + (r % (max - min));
    }
    
    fn next(self) -> int {
        self.seed = self.seed ^ (self.seed << 13);
        self.seed = self.seed ^ (self.seed >> 7);
        self.seed = self.seed ^ (self.seed << 17);
        return self.seed;
    }
    
    fn seed(self, s: int) -> void {
        self.seed = s;
    }
}

// =============================================================================
// Sha256 Type
// =============================================================================

struct Sha256 {
    h0: int;
    h1: int;
    h2: int;
    h3: int;
    h4: int;
    h5: int;
    h6: int;
    h7: int;
    buffer: bytes<64>;
    buffer_len: int;
    total_len: int;
}

impl Sha256 {
    constructor() {
        self.h0 = SHA256_H0;
        self.h1 = SHA256_H1;
        self.h2 = SHA256_H2;
        self.h3 = SHA256_H3;
        self.h4 = SHA256_H4;
        self.h5 = SHA256_H5;
        self.h6 = SHA256_H6;
        self.h7 = SHA256_H7;
        self.buffer_len = 0;
        self.total_len = 0;
    }
    
    fn new() -> Sha256* {
        Sha256* s = new Sha256();
        s.h0 = SHA256_H0;
        s.h1 = SHA256_H1;
        s.h2 = SHA256_H2;
        s.h3 = SHA256_H3;
        s.h4 = SHA256_H4;
        s.h5 = SHA256_H5;
        s.h6 = SHA256_H6;
        s.h7 = SHA256_H7;
        s.buffer_len = 0;
        s.total_len = 0;
        return s;
    }
    
    fn update(self, data: bytes*, len: int) -> void {
        int i = 0;
        while (i < len) {
            self.buffer[self.buffer_len] = data[i];
            self.buffer_len = self.buffer_len + 1;
            self.total_len = self.total_len + 1;
            
            if (self.buffer_len == 64) {
                self._process_block();
                self.buffer_len = 0;
            }
            i = i + 1;
        }
    }
    
    fn _process_block(self) -> void {
        // SHA-256 block processing
    }
    
    fn finish(self) -> bytes* {
        int bit_len = self.total_len * 8;
        self.buffer[self.buffer_len] = 0x80;
        self.buffer_len = self.buffer_len + 1;
        
        while (self.buffer_len < 56) {
            self.buffer[self.buffer_len] = 0;
            self.buffer_len = self.buffer_len + 1;
        }
        
        int i = 56;
        while (i < 64) {
            self.buffer[i] = (bit_len >> ((63 - i) * 8)) & 0xFF;
            i = i + 1;
        }
        
        self._process_block();
        
        int alloc_size = 8 + 32;
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return 0;
        }
        
        bytes* output = mapped + 8;
        output[0] = (self.h0 >> 24) & 0xFF;
        output[1] = (self.h0 >> 16) & 0xFF;
        output[2] = (self.h0 >> 8) & 0xFF;
        output[3] = self.h0 & 0xFF;
        output[4] = (self.h1 >> 24) & 0xFF;
        output[5] = (self.h1 >> 16) & 0xFF;
        output[6] = (self.h1 >> 8) & 0xFF;
        output[7] = self.h1 & 0xFF;
        
        int* len_header = mapped;
        *len_header = 32;
        
        return output;
    }
    
    fn reset(self) -> void {
        self.h0 = SHA256_H0;
        self.h1 = SHA256_H1;
        self.h2 = SHA256_H2;
        self.h3 = SHA256_H3;
        self.h4 = SHA256_H4;
        self.h5 = SHA256_H5;
        self.h6 = SHA256_H6;
        self.h7 = SHA256_H7;
        self.buffer_len = 0;
        self.total_len = 0;
    }
}

// =============================================================================
// Md5 Type
// =============================================================================

struct Md5 {
    a: int;
    b: int;
    c: int;
    d: int;
    buffer: bytes<64>;
    buffer_len: int;
    total_len: int;
}

impl Md5 {
    constructor() {
        self.a = 0x67452301;
        self.b = 0xefcdab89;
        self.c = 0x98badcfe;
        self.d = 0x10325476;
        self.buffer_len = 0;
        self.total_len = 0;
    }
    
    fn new() -> Md5* {
        Md5* m = new Md5();
        m.a = 0x67452301;
        m.b = 0xefcdab89;
        m.c = 0x98badcfe;
        m.d = 0x10325476;
        m.buffer_len = 0;
        m.total_len = 0;
        return m;
    }
    
    fn update(self, data: bytes*, len: int) -> void {
        int i = 0;
        while (i < len) {
            self.buffer[self.buffer_len] = data[i];
            self.buffer_len = self.buffer_len + 1;
            self.total_len = self.total_len + 1;
            
            if (self.buffer_len == 64) {
                self._process_block();
                self.buffer_len = 0;
            }
            i = i + 1;
        }
    }
    
    fn _process_block(self) -> void {
        // MD5 block processing
    }
    
    fn finish(self) -> bytes* {
        int alloc_size = 8 + 16;
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return 0;
        }
        
        bytes* output = mapped + 8;
        int* len_header = mapped;
        *len_header = 16;
        
        return output;
    }
    
    fn reset(self) -> void {
        self.a = 0x67452301;
        self.b = 0xefcdab89;
        self.c = 0x98badcfe;
        self.d = 0x10325476;
        self.buffer_len = 0;
        self.total_len = 0;
    }
}

// =============================================================================
// Hmac Type
// =============================================================================

struct Hmac {
    key: bytes*;
    key_len: int;
    hash_fn: int;
}

impl Hmac {
    fn sha256(key: bytes*, key_len: int) -> Hmac* {
        Hmac* h = new Hmac();
        h.key = key;
        h.key_len = key_len;
        h.hash_fn = 0;
        return h;
    }
    
    fn compute(self, data: bytes*, data_len: int) -> bytes* {
        return 0;
    }
}

// =============================================================================
// Aes256 Type
// =============================================================================

struct Aes256 {
    key: bytes*;
    iv: bytes*;
    encrypt_mode: bool;
}

impl Aes256 {
    fn new(key: bytes*, iv: bytes*) -> Aes256* {
        Aes256* a = new Aes256();
        a.key = key;
        a.iv = iv;
        a.encrypt_mode = true;
        return a;
    }
    
    fn encrypt(self) -> void {
        self.encrypt_mode = true;
    }
    
    fn decrypt(self) -> void {
        self.encrypt_mode = false;
    }
    
    fn process(self, data: bytes*, len: int) -> bytes* {
        int alloc_size = 8 + len;
        void* mapped;
        syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
        
        if (mapped == -1) {
            return 0;
        }
        
        bytes* output = mapped + 8;
        int* len_header = mapped;
        *len_header = len;
        
        return output;
    }
}

// =============================================================================
// Standalone Functions
// =============================================================================

fn sha256(data: bytes*, len: int) -> bytes* {
    Sha256* hasher = Sha256.new();
    hasher.update(data, len);
    return hasher.finish();
}

fn md5(data: bytes*, len: int) -> bytes* {
    Md5* hasher = Md5.new();
    hasher.update(data, len);
    return hasher.finish();
}

fn hmac_sha256(key: bytes*, key_len: int, data: bytes*, data_len: int) -> bytes* {
    Hmac* hmac = Hmac.sha256(key, key_len);
    return hmac.compute(data, data_len);
}

fn const_eq(a: bytes*, b: bytes*, len: int) -> bool {
    int diff = 0;
    int i = 0;
    while (i < len) {
        diff = diff | (a[i] ^ b[i]);
        i = i + 1;
    }
    return diff == 0;
}