// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/threads/threads.mv
// description: Threading module with OOP design
//
// This module provides threading primitives using impl blocks.
// All functions are implemented in pure ManV using syscalls.
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Syscall numbers
int SYS_CLONE = 56;
int SYS_FUTEX = 202;
int SYS_GETTID = 186;
int SYS_TGKILL = 234;
int SYS_NANOSLEEP = 35;
int SYS_SCHED_YIELD = 24;

// Clone flags
int CLONE_VM = 256;
int CLONE_FS = 512;
int CLONE_FILES = 1024;
int CLONE_SIGHAND = 2048;
int CLONE_THREAD = 65536;
int CLONE_SYSVSEM = 131072;
int CLONE_SETTLS = 524288;
int CLONE_PARENT_SETTID = 1048576;
int CLONE_CHILD_CLEARTID = 2097152;

// Futex operations
int FUTEX_WAIT = 0;
int FUTEX_WAKE = 1;
int FUTEX_WAIT_BITSET = 9;
int FUTEX_WAKE_BITSET = 10;

// Memory protection
int PROT_READ = 1;
int PROT_WRITE = 2;
int MAP_PRIVATE = 2;
int MAP_ANONYMOUS = 32;
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;

// Error handling
int ERRNO;

// =============================================================================
// Thread Type
// =============================================================================

struct Thread {
    id: int;
    handle: void*;
    running: bool;
    joined: bool;
    result: void*;
}

impl Thread {
    constructor() {
        self.id = 0;
        self.handle = 0;
        self.running = false;
        self.joined = false;
        self.result = 0;
    }
    
    // Spawn a new thread
    fn spawn(fn_ptr: void*, arg: void*) -> Thread* {
        Thread* t = new Thread();
        
        // Allocate stack
        int stack_size = 65536;  // 64KB
        void* stack;
        syscall SYS_MMAP, 0, stack_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, stack, ERRNO;
        
        if (stack == -1) {
            return t;
        }
        
        // Stack pointer (top of stack)
        void* stack_top = stack + stack_size - 8;
        
        // Clone flags for thread creation
        int flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD;
        
        int tid;
        syscall SYS_CLONE, flags, stack_top, &tid, 0, 0, fn_ptr, arg, tid, ERRNO;
        
        if (tid < 0) {
            syscall SYS_MUNMAP, stack, stack_size, ERRNO;
            return t;
        }
        
        if (tid == 0) {
            // Child thread - call the function
            // This is handled by the runtime
        } else {
            // Parent thread
            t.id = tid;
            t.handle = stack;
            t.running = true;
        }
        
        return t;
    }
    
    // Join thread (wait for completion)
    fn join(self) -> void* {
        if (self.joined || !self.running) {
            return self.result;
        }
        
        // Wait for thread to finish using futex
        int* tid_ptr = &self.id;
        
        while (self.id != 0) {
            syscall SYS_FUTEX, tid_ptr, FUTEX_WAIT, 0, 0, 0, 0, ERRNO;
        }
        
        self.joined = true;
        self.running = false;
        
        return self.result;
    }
    
    // Detach thread
    fn detach(self) -> void {
        self.joined = true;
    }
    
    // Get thread ID
    fn get_id(self) -> int {
        return self.id;
    }
    
    // Check if running
    fn is_running(self) -> bool {
        return self.running && !self.joined;
    }
    
    // Get current thread ID
    fn current_id() -> int {
        int tid;
        syscall SYS_GETTID, tid, ERRNO;
        return tid;
    }
    
    // Yield execution
    fn yield() -> void {
        syscall SYS_SCHED_YIELD, ERRNO;
    }
    
    // Sleep for milliseconds
    fn sleep_ms(ms: int) -> void {
        int sec = ms / 1000;
        int nsec = (ms % 1000) * 1000000;
        int rem_sec;
        int rem_nsec;
        
        syscall SYS_NANOSLEEP, &sec, &nsec, &rem_sec, ERRNO;
    }
    
    // Sleep for microseconds
    fn sleep_us(us: int) -> void {
        int sec = us / 1000000;
        int nsec = (us % 1000000) * 1000;
        int rem_sec;
        int rem_nsec;
        
        syscall SYS_NANOSLEEP, &sec, &nsec, &rem_sec, ERRNO;
    }
}

// =============================================================================
// Mutex Type
// =============================================================================

struct Mutex {
    state: int;      // 0 = unlocked, 1 = locked
    owner: int;      // Owner thread ID
    waiters: int;    // Number of waiting threads
}

impl Mutex {
    constructor() {
        self.state = 0;
        self.owner = 0;
        self.waiters = 0;
    }
    
    // Create new mutex
    fn new() -> Mutex* {
        return new Mutex();
    }
    
    // Lock mutex
    fn lock(self) -> void {
        int tid = Thread.current_id();
        
        // Try to acquire
        while (true) {
            int expected = 0;
            if (__cas(&self.state, expected, 1)) {
                self.owner = tid;
                return;
            }
            
            // Wait
            self.waiters = self.waiters + 1;
            syscall SYS_FUTEX, &self.state, FUTEX_WAIT, 1, 0, 0, 0, ERRNO;
            self.waiters = self.waiters - 1;
        }
    }
    
    // Try to lock mutex
    fn try_lock(self) -> bool {
        int tid = Thread.current_id();
        
        int expected = 0;
        if (__cas(&self.state, expected, 1)) {
            self.owner = tid;
            return true;
        }
        
        return false;
    }
    
    // Unlock mutex
    fn unlock(self) -> void {
        int tid = Thread.current_id();
        
        if (self.owner != tid) {
            return;  // Not owner
        }
        
        self.owner = 0;
        self.state = 0;
        
        // Wake one waiter
        if (self.waiters > 0) {
            syscall SYS_FUTEX, &self.state, FUTEX_WAKE, 1, 0, 0, 0, ERRNO;
        }
    }
    
    // Check if locked
    fn is_locked(self) -> bool {
        return self.state != 0;
    }
}

// =============================================================================
// CondVar Type (Condition Variable)
// =============================================================================

struct CondVar {
    waiters: int;
    sequence: int;
}

impl CondVar {
    constructor() {
        self.waiters = 0;
        self.sequence = 0;
    }
    
    // Create new condition variable
    fn new() -> CondVar* {
        return new CondVar();
    }
    
    // Wait on condition
    fn wait(self, mutex: Mutex*) -> void {
        int seq = self.sequence;
        
        self.waiters = self.waiters + 1;
        mutex.unlock();
        
        // Wait for signal
        syscall SYS_FUTEX, &self.sequence, FUTEX_WAIT, seq, 0, 0, 0, ERRNO;
        
        self.waiters = self.waiters - 1;
        mutex.lock();
    }
    
    // Wait with timeout (returns true if timed out)
    fn wait_timeout(self, mutex: Mutex*, ms: int) -> bool {
        int seq = self.sequence;
        
        self.waiters = self.waiters + 1;
        mutex.unlock();
        
        // Setup timeout
        int sec = ms / 1000;
        int nsec = (ms % 1000) * 1000000;
        
        int result;
        syscall SYS_FUTEX, &self.sequence, FUTEX_WAIT_BITSET, seq, &sec, 0, 0, result, ERRNO;
        
        self.waiters = self.waiters - 1;
        mutex.lock();
        
        return result != 0;
    }
    
    // Signal one waiter
    fn signal(self) -> void {
        self.sequence = self.sequence + 1;
        
        if (self.waiters > 0) {
            syscall SYS_FUTEX, &self.sequence, FUTEX_WAKE, 1, 0, 0, 0, ERRNO;
        }
    }
    
    // Signal all waiters
    fn broadcast(self) -> void {
        self.sequence = self.sequence + 1;
        
        if (self.waiters > 0) {
            syscall SYS_FUTEX, &self.sequence, FUTEX_WAKE, 2147483647, 0, 0, 0, ERRNO;
        }
    }
}

// =============================================================================
// RwLock Type (Read-Write Lock)
// =============================================================================

struct RwLock {
    readers: int;
    writer: int;    // 0 or 1
    write_waiters: int;
    read_waiters: int;
}

impl RwLock {
    constructor() {
        self.readers = 0;
        self.writer = 0;
        self.write_waiters = 0;
        self.read_waiters = 0;
    }
    
    // Create new read-write lock
    fn new() -> RwLock* {
        return new RwLock();
    }
    
    // Acquire read lock
    fn read(self) -> void {
        while (true) {
            // Try to acquire read lock
            if (self.writer == 0 && self.write_waiters == 0) {
                self.readers = self.readers + 1;
                return;
            }
            
            // Wait
            self.read_waiters = self.read_waiters + 1;
            syscall SYS_FUTEX, &self.read_waiters, FUTEX_WAIT, 0, 0, 0, 0, ERRNO;
            self.read_waiters = self.read_waiters - 1;
        }
    }
    
    // Release read lock
    fn read_unlock(self) -> void {
        self.readers = self.readers - 1;
        
        // Wake writers if no more readers
        if (self.readers == 0 && self.write_waiters > 0) {
            syscall SYS_FUTEX, &self.writer, FUTEX_WAKE, 1, 0, 0, 0, ERRNO;
        }
    }
    
    // Acquire write lock
    fn write(self) -> void {
        while (true) {
            // Try to acquire write lock
            if (self.writer == 0 && self.readers == 0) {
                self.writer = 1;
                return;
            }
            
            // Wait
            self.write_waiters = self.write_waiters + 1;
            syscall SYS_FUTEX, &self.writer, FUTEX_WAIT, 1, 0, 0, 0, ERRNO;
            self.write_waiters = self.write_waiters - 1;
        }
    }
    
    // Release write lock
    fn write_unlock(self) -> void {
        self.writer = 0;
        
        // Prefer readers over writers
        if (self.read_waiters > 0) {
            syscall SYS_FUTEX, &self.read_waiters, FUTEX_WAKE, 2147483647, 0, 0, 0, ERRNO;
        } else if (self.write_waiters > 0) {
            syscall SYS_FUTEX, &self.writer, FUTEX_WAKE, 1, 0, 0, 0, ERRNO;
        }
    }
}

// =============================================================================
// Semaphore Type
// =============================================================================

struct Semaphore {
    count: int;
    waiters: int;
}

impl Semaphore {
    constructor(initial: int) {
        self.count = initial;
        self.waiters = 0;
    }
    
    // Create new semaphore
    fn new(count: int) -> Semaphore* {
        return new Semaphore(count);
    }
    
    // Wait (decrement)
    fn wait(self) -> void {
        while (true) {
            int c = self.count;
            if (c > 0) {
                if (__cas(&self.count, c, c - 1)) {
                    return;
                }
            }
            
            // Wait
            self.waiters = self.waiters + 1;
            syscall SYS_FUTEX, &self.count, FUTEX_WAIT, 0, 0, 0, 0, ERRNO;
            self.waiters = self.waiters - 1;
        }
    }
    
    // Try wait (returns true on success)
    fn try_wait(self) -> bool {
        int c = self.count;
        if (c > 0) {
            return __cas(&self.count, c, c - 1);
        }
        return false;
    }
    
    // Post (increment)
    fn post(self) -> void {
        self.count = self.count + 1;
        
        if (self.waiters > 0) {
            syscall SYS_FUTEX, &self.count, FUTEX_WAKE, 1, 0, 0, 0, ERRNO;
        }
    }
    
    // Get current count
    fn get_count(self) -> int {
        return self.count;
    }
}

// =============================================================================
// Spinlock Type
// =============================================================================

struct Spinlock {
    locked: int;
}

impl Spinlock {
    constructor() {
        self.locked = 0;
    }
    
    fn new() -> Spinlock* {
        return new Spinlock();
    }
    
    fn lock(self) -> void {
        while (true) {
            int expected = 0;
            if (__cas(&self.locked, expected, 1)) {
                return;
            }
            
            // Spin with pause
            while (self.locked != 0) {
                __pause();  // CPU pause instruction
            }
        }
    }
    
    fn try_lock(self) -> bool {
        int expected = 0;
        return __cas(&self.locked, expected, 1);
    }
    
    fn unlock(self) -> void {
        self.locked = 0;
    }
    
    fn is_locked(self) -> bool {
        return self.locked != 0;
    }
}

// =============================================================================
// AtomicInt Type
// =============================================================================

struct AtomicInt {
    value: int;
}

impl AtomicInt {
    constructor(initial: int) {
        self.value = initial;
    }
    
    fn new(value: int) -> AtomicInt* {
        return new AtomicInt(value);
    }
    
    // Load value
    fn load(self) -> int {
        return self.value;
    }
    
    // Store value
    fn store(self, value: int) -> void {
        self.value = value;
    }
    
    // Fetch and add (returns old value)
    fn fetch_add(self, value: int) -> int {
        return __atomic_fetch_add(&self.value, value);
    }
    
    // Compare and swap
    fn cas(self, expected: int, desired: int) -> bool {
        return __cas(&self.value, expected, desired);
    }
    
    // Swap (returns old value)
    fn swap(self, value: int) -> int {
        return __atomic_swap(&self.value, value);
    }
}