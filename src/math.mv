// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without resolution, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/src/math.mv
// description: Math module with OOP design - Math constants and functions
//
// This module provides mathematical operations using impl blocks.
// All functions are implemented in pure ManV using compiler intrinsics.
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Mathematical constants
float PI = 3.14159265358979323846;
float TAU = 6.28318530717958647692;
float E = 2.71828182845904523536;
float PHI = 1.61803398874989484820;  // Golden ratio
float SQRT2 = 1.41421356237309504880;
float SQRT3 = 1.73205080756887729353;
float LN2 = 0.69314718055994530941;
float LN10 = 2.30258509299404568401;
float EPSILON = 2.22044604925031308085e-16;

// =============================================================================
// Math Type - Static math methods
// =============================================================================

struct Math {
    // Placeholder - all methods are static
}

impl Math {
    // =========================================================================
    // Basic Operations
    // =========================================================================
    
    // Absolute value for float
    fn abs_f(x: float) -> float {
        return __fabs(x);
    }
    
    // Absolute value for int
    fn abs_i(x: int) -> int {
        if (x < 0) {
            return -x;
        }
        return x;
    }
    
    // Minimum of two floats
    fn min_f(a: float, b: float) -> float {
        return a < b ? a : b;
    }
    
    // Minimum of two ints
    fn min_i(a: int, b: int) -> int {
        return a < b ? a : b;
    }
    
    // Maximum of two floats
    fn max_f(a: float, b: float) -> float {
        return a > b ? a : b;
    }
    
    // Maximum of two ints
    fn max_i(a: int, b: int) -> int {
        return a > b ? a : b;
    }
    
    // Clamp float to range
    fn clamp_f(x: float, min_val: float, max_val: float) -> float {
        if (x < min_val) { return min_val; }
        if (x > max_val) { return max_val; }
        return x;
    }
    
    // Clamp int to range
    fn clamp_i(x: int, min_val: int, max_val: int) -> int {
        if (x < min_val) { return min_val; }
        if (x > max_val) { return max_val; }
        return x;
    }
    
    // Sign of float (-1, 0, or 1)
    fn sign_f(x: float) -> int {
        if (x < 0.0) { return -1; }
        if (x > 0.0) { return 1; }
        return 0;
    }
    
    // Sign of int (-1, 0, or 1)
    fn sign_i(x: int) -> int {
        if (x < 0) { return -1; }
        if (x > 0) { return 1; }
        return 0;
    }
    
    // =========================================================================
    // Rounding Functions
    // =========================================================================
    
    // Floor
    fn floor(x: float) -> float {
        return __floor(x);
    }
    
    // Ceiling
    fn ceil(x: float) -> float {
        return __ceil(x);
    }
    
    // Round to nearest integer
    fn round(x: float) -> float {
        return __round(x);
    }
    
    // Truncate toward zero
    fn trunc(x: float) -> float {
        return __trunc(x);
    }
    
    // =========================================================================
    // Power and Exponential Functions
    // =========================================================================
    
    // Square root
    fn sqrt(x: float) -> float {
        return __sqrt(x);
    }
    
    // Cube root
    fn cbrt(x: float) -> float {
        return __cbrt(x);
    }
    
    // Power (x^y)
    fn pow(x: float, y: float) -> float {
        return __pow(x, y);
    }
    
    // Exponential (e^x)
    fn exp(x: float) -> float {
        return __exp(x);
    }
    
    // Natural logarithm
    fn ln(x: float) -> float {
        return __log(x);
    }
    
    // Base-10 logarithm
    fn log10(x: float) -> float {
        return __log10(x);
    }
    
    // Base-2 logarithm
    fn log2(x: float) -> float {
        return __log2(x);
    }
    
    // Logarithm with arbitrary base
    fn log(x: float, base: float) -> float {
        return __log(x) / __log(base);
    }
    
    // =========================================================================
    // Trigonometric Functions
    // =========================================================================
    
    // Sine
    fn sin(x: float) -> float {
        return __sin(x);
    }
    
    // Cosine
    fn cos(x: float) -> float {
        return __cos(x);
    }
    
    // Tangent
    fn tan(x: float) -> float {
        return __tan(x);
    }
    
    // Arc sine
    fn asin(x: float) -> float {
        return __asin(x);
    }
    
    // Arc cosine
    fn acos(x: float) -> float {
        return __acos(x);
    }
    
    // Arc tangent
    fn atan(x: float) -> float {
        return __atan(x);
    }
    
    // Arc tangent of y/x (handles quadrant correctly)
    fn atan2(y: float, x: float) -> float {
        return __atan2(y, x);
    }
    
    // =========================================================================
    // Hyperbolic Functions
    // =========================================================================
    
    // Hyperbolic sine
    fn sinh(x: float) -> float {
        return __sinh(x);
    }
    
    // Hyperbolic cosine
    fn cosh(x: float) -> float {
        return __cosh(x);
    }
    
    // Hyperbolic tangent
    fn tanh(x: float) -> float {
        return __tanh(x);
    }
    
    // =========================================================================
    // Special Functions
    // =========================================================================
    
    // Hypotenuse: sqrt(x^2 + y^2)
    fn hypot(x: float, y: float) -> float {
        return __sqrt(x * x + y * y);
    }
    
    // Modulo (floating point remainder)
    fn fmod(x: float, y: float) -> float {
        return __fmod(x, y);
    }
    
    // Remainder with quotient
    fn remainder(x: float, y: float) -> float {
        return __remainder(x, y);
    }
    
    // =========================================================================
    // Comparison Functions
    // =========================================================================
    
    // Check if NaN
    fn is_nan(x: float) -> bool {
        return __isnan(x);
    }
    
    // Check if infinity
    fn is_inf(x: float) -> bool {
        return __isinf(x);
    }
    
    // Check if finite (not NaN or infinity)
    fn is_finite(x: float) -> bool {
        return !__isnan(x) && !__isinf(x);
    }
    
    // Check if normal (not NaN, infinity, or subnormal)
    fn is_normal(x: float) -> bool {
        return __isnormal(x);
    }
    
    // Check if negative zero
    fn is_negative_zero(x: float) -> bool {
        // Check if x is zero and has negative sign
        return x == 0.0 && __signbit(x);
    }
    
    // Compare two floats (returns -1, 0, or 1)
    fn compare_f(a: float, b: float) -> int {
        if (a < b) { return -1; }
        if (a > b) { return 1; }
        return 0;
    }
    
    // Check approximate equality within epsilon
    fn approx_eq(a: float, b: float, epsilon: float) -> bool {
        return Math.abs_f(a - b) <= epsilon;
    }
    
    // Check approximate equality within relative epsilon
    fn rel_approx_eq(a: float, b: float, rel_epsilon: float) -> bool {
        float diff = Math.abs_f(a - b);
        float larger = Math.max_f(Math.abs_f(a), Math.abs_f(b));
        return diff <= larger * rel_epsilon;
    }
    
    // =========================================================================
    // Integer Math Functions
    // =========================================================================
    
    // Integer square root
    fn isqrt(n: int) -> int {
        if (n < 0) { return 0; }
        if (n <= 1) { return n; }
        
        int x = n;
        int y = (x + 1) / 2;
        
        while (y < x) {
            x = y;
            y = (x + n / x) / 2;
        }
        
        return x;
    }
    
    // Integer power
    fn ipow(base: int, exp: int) -> int {
        if (exp < 0) { return 0; }
        if (exp == 0) { return 1; }
        
        int result = 1;
        int b = base;
        int e = exp;
        
        while (e > 0) {
            if ((e & 1) == 1) {
                result = result * b;
            }
            b = b * b;
            e = e >> 1;
        }
        
        return result;
    }
    
    // Greatest common divisor
    fn gcd(a: int, b: int) -> int {
        if (a < 0) { a = -a; }
        if (b < 0) { b = -b; }
        
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        
        return a;
    }
    
    // Least common multiple
    fn lcm(a: int, b: int) -> int {
        if (a == 0 || b == 0) { return 0; }
        return Math.abs_i(a / Math.gcd(a, b) * b);
    }
    
    // Check if prime
    fn is_prime(n: int) -> bool {
        if (n < 2) { return false; }
        if (n == 2) { return true; }
        if (n % 2 == 0) { return false; }
        
        int sqrt_n = Math.isqrt(n);
        int i = 3;
        
        while (i <= sqrt_n) {
            if (n % i == 0) { return false; }
            i = i + 2;
        }
        
        return true;
    }
    
    // Factorial (returns 0 for n > 20 due to overflow)
    fn factorial(n: int) -> int {
        if (n < 0) { return 0; }
        if (n > 20) { return 0; }  // Would overflow int64
        
        int result = 1;
        int i = 2;
        
        while (i <= n) {
            result = result * i;
            i = i + 1;
        }
        
        return result;
    }
    
    // Fibonacci number
    fn fibonacci(n: int) -> int {
        if (n < 0) { return 0; }
        if (n == 0) { return 0; }
        if (n == 1) { return 1; }
        
        int a = 0;
        int b = 1;
        int i = 2;
        
        while (i <= n) {
            int temp = a + b;
            a = b;
            b = temp;
            i = i + 1;
        }
        
        return b;
    }
    
    // =========================================================================
    // Interpolation Functions
    // =========================================================================
    
    // Linear interpolation
    fn lerp(a: float, b: float, t: float) -> float {
        return a + t * (b - a);
    }
    
    // Inverse linear interpolation (get t from value)
    fn inverse_lerp(a: float, b: float, value: float) -> float {
        return (value - a) / (b - a);
    }
    
    // Remap value from one range to another
    fn remap(value: float, in_min: float, in_max: float, out_min: float, out_max: float) -> float {
        float t = Math.inverse_lerp(in_min, in_max, value);
        return Math.lerp(out_min, out_max, t);
    }
    
    // Smooth step (Hermite interpolation)
    fn smoothstep(edge0: float, edge1: float, x: float) -> float {
        float t = Math.clamp_f((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        return t * t * (3.0 - 2.0 * t);
    }
    
    // Smoother step (Ken Perlin's version)
    fn smootherstep(edge0: float, edge1: float, x: float) -> float {
        float t = Math.clamp_f((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
    }
    
    // =========================================================================
    // Angle Conversion
    // =========================================================================
    
    // Degrees to radians
    fn deg_to_rad(degrees: float) -> float {
        return degrees * PI / 180.0;
    }
    
    // Radians to degrees
    fn rad_to_deg(radians: float) -> float {
        return radians * 180.0 / PI;
    }
    
    // Normalize angle to [0, 2*PI)
    fn normalize_angle(angle: float) -> float {
        float result = angle % TAU;
        if (result < 0.0) {
            result = result + TAU;
        }
        return result;
    }
    
    // =========================================================================
    // Random Number Generation
    // =========================================================================
    
    // Simple LCG random state
    int _rand_state = 1;
    
    // Seed the random number generator
    fn srand(seed: int) -> void {
        Math._rand_state = seed != 0 ? seed : 1;
    }
    
    // Generate random integer
    fn rand() -> int {
        // LCG constants (glibc)
        Math._rand_state = Math._rand_state * 1103515245 + 12345;
        return (Math._rand_state >> 16) & 0x7FFF;
    }
    
    // Generate random float in [0, 1)
    fn rand_f() -> float {
        return Math.rand() / 32768.0;
    }
    
    // Generate random float in [min, max)
    fn rand_range_f(min: float, max: float) -> float {
        return min + Math.rand_f() * (max - min);
    }
    
    // Generate random int in [min, max]
    fn rand_range_i(min: int, max: int) -> int {
        return min + Math.rand() % (max - min + 1);
    }
    
    // =========================================================================
    // Utility Functions
    // =========================================================================
    
    // Count set bits
    fn popcount(x: int) -> int {
        int count = 0;
        int n = x;
        
        while (n != 0) {
            count = count + 1;
            n = n & (n - 1);
        }
        
        return count;
    }
    
    // Count trailing zeros
    fn ctz(x: int) -> int {
        if (x == 0) { return 64; }
        
        int count = 0;
        int n = x;
        
        while ((n & 1) == 0) {
            count = count + 1;
            n = n >> 1;
        }
        
        return count;
    }
    
    // Count leading zeros
    fn clz(x: int) -> int {
        if (x == 0) { return 64; }
        
        int n = x;
        int count = 0;
        
        if ((n & 0xFFFFFFFF00000000) == 0) { count = count + 32; n = n << 32; }
        if ((n & 0xFFFF000000000000) == 0) { count = count + 16; n = n << 16; }
        if ((n & 0xFF00000000000000) == 0) { count = count + 8; n = n << 8; }
        if ((n & 0xF000000000000000) == 0) { count = count + 4; n = n << 4; }
        if ((n & 0xC000000000000000) == 0) { count = count + 2; n = n << 2; }
        if ((n & 0x8000000000000000) == 0) { count = count + 1; }
        
        return count;
    }
    
    // Next power of two
    fn next_pow2(x: int) -> int {
        if (x <= 1) { return 1; }
        
        int n = x - 1;
        n = n | (n >> 1);
        n = n | (n >> 2);
        n = n | (n >> 4);
        n = n | (n >> 8);
        n = n | (n >> 16);
        n = n | (n >> 32);
        
        return n + 1;
    }
    
    // Check if power of two
    fn is_pow2(x: int) -> bool {
        return x > 0 && (x & (x - 1)) == 0;
    }
    
    // Align value up to alignment
    fn align_up(x: int, alignment: int) -> int {
        return (x + alignment - 1) & ~(alignment - 1);
    }
    
    // Align value down to alignment
    fn align_down(x: int, alignment: int) -> int {
        return x & ~(alignment - 1);
    }
}

// =============================================================================
// Vector2 Type
// =============================================================================

struct Vec2 {
    x: float;
    y: float;
}

impl Vec2 {
    constructor(x: float, y: float) {
        self.x = x;
        self.y = y;
    }
    
    fn zero() -> Vec2* {
        return new Vec2(0.0, 0.0);
    }
    
    fn one() -> Vec2* {
        return new Vec2(1.0, 1.0);
    }
    
    fn add(self, other: Vec2*) -> Vec2* {
        return new Vec2(self.x + other.x, self.y + other.y);
    }
    
    fn sub(self, other: Vec2*) -> Vec2* {
        return new Vec2(self.x - other.x, self.y - other.y);
    }
    
    fn mul(self, scalar: float) -> Vec2* {
        return new Vec2(self.x * scalar, self.y * scalar);
    }
    
    fn div(self, scalar: float) -> Vec2* {
        return new Vec2(self.x / scalar, self.y / scalar);
    }
    
    fn dot(self, other: Vec2*) -> float {
        return self.x * other.x + self.y * other.y;
    }
    
    fn length(self) -> float {
        return Math.sqrt(self.dot(self));
    }
    
    fn length_sq(self) -> float {
        return self.dot(self);
    }
    
    fn normalize(self) -> Vec2* {
        float len = self.length();
        if (len > 0.0) {
            return self.div(len);
        }
        return Vec2.zero();
    }
    
    fn distance(self, other: Vec2*) -> float {
        return self.sub(other).length();
    }
    
    fn angle(self) -> float {
        return Math.atan2(self.y, self.x);
    }
    
    fn rotate(self, angle: float) -> Vec2* {
        float cos_a = Math.cos(angle);
        float sin_a = Math.sin(angle);
        return new Vec2(
            self.x * cos_a - self.y * sin_a,
            self.x * sin_a + self.y * cos_a
        );
    }
    
    fn lerp(self, other: Vec2*, t: float) -> Vec2* {
        return new Vec2(
            Math.lerp(self.x, other.x, t),
            Math.lerp(self.y, other.y, t)
        );
    }
}

// =============================================================================
// Vector3 Type
// =============================================================================

struct Vec3 {
    x: float;
    y: float;
    z: float;
}

impl Vec3 {
    constructor(x: float, y: float, z: float) {
        self.x = x;
        self.y = y;
        self.z = z;
    }
    
    fn zero() -> Vec3* {
        return new Vec3(0.0, 0.0, 0.0);
    }
    
    fn one() -> Vec3* {
        return new Vec3(1.0, 1.0, 1.0);
    }
    
    fn add(self, other: Vec3*) -> Vec3* {
        return new Vec3(self.x + other.x, self.y + other.y, self.z + other.z);
    }
    
    fn sub(self, other: Vec3*) -> Vec3* {
        return new Vec3(self.x - other.x, self.y - other.y, self.z - other.z);
    }
    
    fn mul(self, scalar: float) -> Vec3* {
        return new Vec3(self.x * scalar, self.y * scalar, self.z * scalar);
    }
    
    fn div(self, scalar: float) -> Vec3* {
        return new Vec3(self.x / scalar, self.y / scalar, self.z / scalar);
    }
    
    fn dot(self, other: Vec3*) -> float {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
    
    fn cross(self, other: Vec3*) -> Vec3* {
        return new Vec3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        );
    }
    
    fn length(self) -> float {
        return Math.sqrt(self.dot(self));
    }
    
    fn length_sq(self) -> float {
        return self.dot(self);
    }
    
    fn normalize(self) -> Vec3* {
        float len = self.length();
        if (len > 0.0) {
            return self.div(len);
        }
        return Vec3.zero();
    }
    
    fn distance(self, other: Vec3*) -> float {
        return self.sub(other).length();
    }
    
    fn lerp(self, other: Vec3*, t: float) -> Vec3* {
        return new Vec3(
            Math.lerp(self.x, other.x, t),
            Math.lerp(self.y, other.y, t),
            Math.lerp(self.z, other.z, t)
        );
    }
}