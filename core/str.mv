// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// =============================================================================
// file: stdlib/core/str.mv
// description: String functions implemented in pure ManV
//
// This module provides string manipulation functions for ManV programs.
// All functions are implemented using compiler intrinsics and syscalls,
// without any assembly code.
//
// String Memory Layout:
// ---------------------
// ManV strings use a length-prefixed layout:
//   [len: 8 bytes][data: N bytes][null: 1 byte]
//
// The string pointer points to the start of the data section.
// The length is stored 8 bytes before the data pointer.
//
// Functions:
// ---------
// - str_len:        Get byte length (O(1))
// - str_char_len:   Get UTF-8 character count (O(n))
// - str_is_empty:   Check if string is empty
// - str_concat:     Concatenate two strings
// - str_slice:      Extract a substring
// - str_contains:   Check if string contains substring
// - str_starts_with: Check if string starts with prefix
// - str_ends_with:  Check if string ends with suffix
// - str_find:       Find first occurrence of substring
//
// Dependencies:
// ------------
// - __memcpy: Memory copy intrinsic
// - __strlen: String length intrinsic (for C strings)
// - mmap syscall: Memory allocation for concatenation
//
// Author: ramsy0dev
// License: MIT
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

// Syscall numbers for Linux x86-64
int SYS_MMAP = 9;
int SYS_MUNMAP = 11;

// Memory protection flags
int PROT_READ = 1;
int PROT_WRITE = 2;

// Memory mapping flags
int MAP_PRIVATE = 2;
int MAP_ANONYMOUS = 32;

// Error handling
int ERRNO;

// =============================================================================
// String Length Functions
// =============================================================================

// -----------------------------------------------------------------------------
// str_len(str* s) -> int
// -----------------------------------------------------------------------------
// Returns the byte length of a ManV string in O(1) time.
//
// The length is stored in a header immediately before the string data.
// This allows constant-time length queries without scanning the string.
//
// Parameters:
//   s: Pointer to the string data (NOT the length header)
//
// Returns:
//   The byte length of the string (not including null terminator)
//
// Example:
//   str* greeting = "Hello, World!";
//   int len = str_len(greeting);  // len = 13
//
// Memory Layout:
//   [len: 8 bytes][data: len bytes][null: 1 byte]
//                  ^
//                  s points here
// -----------------------------------------------------------------------------
fn str_len(s: str*) -> int {
    // The length is stored 8 bytes before the data pointer
    // We load it directly from memory
    // This is equivalent to: return *(s - 8);
    
    // Use inline assembly-like pointer arithmetic
    // In ManV, we can access the length header directly
    int* len_ptr = (s - 8);
    return *len_ptr;
}

// -----------------------------------------------------------------------------
// str_char_len(str* s) -> int
// -----------------------------------------------------------------------------
// Returns the number of UTF-8 characters in a string.
//
// This is NOT the same as byte length! UTF-8 characters can be 1-4 bytes.
// ASCII characters are 1 byte, but Unicode characters can be longer.
//
// UTF-8 Lead Byte Patterns:
//   0xxxxxxx: 1-byte character (ASCII)
//   110xxxxx: 2-byte character
//   1110xxxx: 3-byte character
//   11110xxx: 4-byte character
//
// Parameters:
//   s: Pointer to the string data
//
// Returns:
//   The number of UTF-8 characters (code points)
//
// Example:
//   str* ascii = "Hello";       // 5 bytes, 5 chars
//   str* unicode = "hÃ©llo";     // 6 bytes, 5 chars (Ã© is 2 bytes)
//   str* emoji = "hiðŸ‘‹";        // 6 bytes, 3 chars (ðŸ‘‹ is 4 bytes)
//
// Performance: O(n) where n is the byte length
// -----------------------------------------------------------------------------
fn str_char_len(s: str*) -> int {
    int byte_len = str_len(s);
    int char_count = 0;
    int pos = 0;
    
    while (pos < byte_len) {
        // Get the current byte
        int byte = s[pos];
        
        // Count this character
        char_count = char_count + 1;
        
        // Determine character length based on lead byte
        if ((byte & 0x80) == 0) {
            // ASCII: 0xxxxxxx (1 byte)
            pos = pos + 1;
        } else if ((byte & 0xE0) == 0xC0) {
            // 2-byte character: 110xxxxx
            pos = pos + 2;
        } else if ((byte & 0xF0) == 0xE0) {
            // 3-byte character: 1110xxxx
            pos = pos + 3;
        } else if ((byte & 0xF8) == 0xF0) {
            // 4-byte character: 11110xxx
            pos = pos + 4;
        } else {
            // Invalid UTF-8, treat as single byte
            pos = pos + 1;
        }
    }
    
    return char_count;
}

// -----------------------------------------------------------------------------
// str_is_empty(str* s) -> bool
// -----------------------------------------------------------------------------
// Checks if a string is empty.
//
// Parameters:
//   s: Pointer to the string data
//
// Returns:
//   true if the string has zero length, false otherwise
//
// Example:
//   str* empty = "";
//   if (str_is_empty(empty)) {
//       // Handle empty string
//   }
// -----------------------------------------------------------------------------
fn str_is_empty(s: str*) -> bool {
    return str_len(s) == 0;
}

// =============================================================================
// String Manipulation Functions
// =============================================================================

// -----------------------------------------------------------------------------
// str_concat(str* s1, str* s2) -> str*
// -----------------------------------------------------------------------------
// Concatenates two strings and returns a new heap-allocated string.
//
// This function allocates memory for the new string using mmap.
// The caller is responsible for freeing this memory when done.
//
// Parameters:
//   s1: First string
//   s2: Second string
//
// Returns:
//   Pointer to newly allocated concatenated string
//   Returns null on allocation failure
//
// Example:
//   str* first = "Hello, ";
//   str* second = "World!";
//   str* result = str_concat(first, second);  // "Hello, World!"
//
// Memory Management:
//   The returned string must be freed by the caller.
//   Use munmap with the returned pointer - 8 to free the entire allocation.
//
// Performance: O(n + m) where n = len(s1), m = len(s2)
// -----------------------------------------------------------------------------
fn str_concat(s1: str*, s2: str*) -> str* {
    int len1 = str_len(s1);
    int len2 = str_len(s2);
    int total_len = len1 + len2;
    
    // Calculate allocation size:
    // 8 bytes (length header) + total_len + 1 (null terminator)
    int alloc_size = 8 + total_len + 1;
    
    // Align to 16 bytes for better memory alignment
    alloc_size = (alloc_size + 15) & ~15;
    
    // Allocate memory using mmap syscall
    // void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset)
    void* mapped;
    syscall SYS_MMAP, 0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, mapped, ERRNO;
    
    // Check for allocation failure
    if (mapped == -1) {
        return 0;  // Return null on failure
    }
    
    // Store length in header (first 8 bytes)
    int* len_header = mapped;
    *len_header = total_len;
    
    // Calculate pointer to data section (after header)
    str* result = mapped + 8;
    
    // Copy first string
    if (len1 > 0) {
        __memcpy(result, s1, len1);
    }
    
    // Copy second string
    if (len2 > 0) {
        __memcpy(result + len1, s2, len2);
    }
    
    // Add null terminator
    result[total_len] = 0;
    
    return result;
}

// -----------------------------------------------------------------------------
// str_slice(str* s, int start, int end) -> str*
// -----------------------------------------------------------------------------
// Extracts a substring from start to end (exclusive).
//
// This function returns a VIEW into the original string, NOT a copy.
// The returned pointer points to the same memory as the original.
// Do NOT free the slice independently of the original string.
//
// Parameters:
//   s:     Source string
//   start: Start index (inclusive, 0-based)
//   end:   End index (exclusive)
//
// Returns:
//   Pointer to the substring within the original string
//   Returns null if bounds are invalid
//
// Example:
//   str* text = "Hello, World!";
//   str* world = str_slice(text, 7, 12);  // "World"
//
// Panics:
//   Currently returns null on invalid bounds.
//   In the future, this may panic in debug mode.
//
// Performance: O(1) - just pointer arithmetic
// -----------------------------------------------------------------------------
fn str_slice(s: str*, start: int, end: int) -> str* {
    int len = str_len(s);
    
    // Validate bounds
    if (start < 0 || end > len || start > end) {
        return 0;  // Invalid bounds
    }
    
    // Return pointer to the slice
    return s + start;
}

// -----------------------------------------------------------------------------
// str_try_slice(str* s, int start, int end) -> Option<str>
// -----------------------------------------------------------------------------
// Safely extracts a substring, returning Option<str>.
//
// This is the safe version of str_slice that returns None on invalid bounds
// instead of panicking or returning null.
//
// Parameters:
//   s:     Source string
//   start: Start index (inclusive, 0-based)
//   end:   End index (exclusive)
//
// Returns:
//   Option<str>: Some(slice) if valid, None if invalid bounds
//
// Example:
//   str* text = "Hello";
//   Option<str> result = str_try_slice(text, 0, 3);
//   if (result.has_value) {
//       // Use result.value
//   }
// -----------------------------------------------------------------------------
fn str_try_slice(s: str*, start: int, end: int) -> Option<str> {
    int len = str_len(s);
    
    // Validate bounds
    if (start < 0 || end > len || start > end) {
        return Option<str>{ has_value: false, value: "" };
    }
    
    // Return Some(slice)
    return Option<str>{ has_value: true, value: s + start };
}

// =============================================================================
// String Search Functions
// =============================================================================

// -----------------------------------------------------------------------------
// str_contains(str* s, str* substr) -> bool
// -----------------------------------------------------------------------------
// Checks if a string contains a substring.
//
// This uses a simple O(n*m) search algorithm. For large strings,
// consider using a more efficient algorithm like Boyer-Moore.
//
// Parameters:
//   s:      String to search in
//   substr: Substring to search for
//
// Returns:
//   true if substr is found anywhere in s, false otherwise
//
// Example:
//   str* text = "Hello, World!";
//   bool has_world = str_contains(text, "World");  // true
//   bool has_foo = str_contains(text, "foo");      // false
//
// Performance: O(n * m) worst case where n = len(s), m = len(substr)
// -----------------------------------------------------------------------------
fn str_contains(s: str*, substr: str*) -> bool {
    int len = str_len(s);
    int substr_len = str_len(substr);
    
    // Empty substring is always found
    if (substr_len == 0) {
        return true;
    }
    
    // Substring longer than string can't be found
    if (substr_len > len) {
        return false;
    }
    
    // Search for substring
    int max_pos = len - substr_len;
    int pos = 0;
    
    while (pos <= max_pos) {
        // Compare substring at current position
        bool match = true;
        int i = 0;
        
        while (i < substr_len && match) {
            if (s[pos + i] != substr[i]) {
                match = false;
            }
            i = i + 1;
        }
        
        if (match) {
            return true;
        }
        
        pos = pos + 1;
    }
    
    return false;
}

// -----------------------------------------------------------------------------
// str_starts_with(str* s, str* prefix) -> bool
// -----------------------------------------------------------------------------
// Checks if a string starts with a given prefix.
//
// Parameters:
//   s:      String to check
//   prefix: Prefix to look for
//
// Returns:
//   true if s starts with prefix, false otherwise
//
// Example:
//   str* filename = "document.txt";
//   bool is_doc = str_starts_with(filename, "doc");  // true
// -----------------------------------------------------------------------------
fn str_starts_with(s: str*, prefix: str*) -> bool {
    int len = str_len(s);
    int prefix_len = str_len(prefix);
    
    // Prefix longer than string
    if (prefix_len > len) {
        return false;
    }
    
    // Compare first prefix_len bytes
    int i = 0;
    while (i < prefix_len) {
        if (s[i] != prefix[i]) {
            return false;
        }
        i = i + 1;
    }
    
    return true;
}

// -----------------------------------------------------------------------------
// str_ends_with(str* s, str* suffix) -> bool
// -----------------------------------------------------------------------------
// Checks if a string ends with a given suffix.
//
// Parameters:
//   s:      String to check
//   suffix: Suffix to look for
//
// Returns:
//   true if s ends with suffix, false otherwise
//
// Example:
//   str* filename = "document.txt";
//   bool is_txt = str_ends_with(filename, ".txt");  // true
// -----------------------------------------------------------------------------
fn str_ends_with(s: str*, suffix: str*) -> bool {
    int len = str_len(s);
    int suffix_len = str_len(suffix);
    
    // Suffix longer than string
    if (suffix_len > len) {
        return false;
    }
    
    // Compare last suffix_len bytes
    int start = len - suffix_len;
    int i = 0;
    
    while (i < suffix_len) {
        if (s[start + i] != suffix[i]) {
            return false;
        }
        i = i + 1;
    }
    
    return true;
}

// -----------------------------------------------------------------------------
// str_find(str* s, str* substr) -> Option<int>
// -----------------------------------------------------------------------------
// Finds the first occurrence of a substring.
//
// Parameters:
//   s:      String to search in
//   substr: Substring to find
//
// Returns:
//   Option<int>: Some(index) if found, None if not found
//
// Example:
//   str* text = "Hello, World!";
//   Option<int> pos = str_find(text, "World");
//   // pos.has_value = true, pos.value = 7
// -----------------------------------------------------------------------------
fn str_find(s: str*, substr: str*) -> Option<int> {
    int len = str_len(s);
    int substr_len = str_len(substr);
    
    // Empty substring found at position 0
    if (substr_len == 0) {
        return Option<int>{ has_value: true, value: 0 };
    }
    
    // Substring longer than string
    if (substr_len > len) {
        return Option<int>{ has_value: false, value: -1 };
    }
    
    // Search for substring
    int max_pos = len - substr_len;
    int pos = 0;
    
    while (pos <= max_pos) {
        // Compare substring at current position
        bool match = true;
        int i = 0;
        
        while (i < substr_len && match) {
            if (s[pos + i] != substr[i]) {
                match = false;
            }
            i = i + 1;
        }
        
        if (match) {
            return Option<int>{ has_value: true, value: pos };
        }
        
        pos = pos + 1;
    }
    
    return Option<int>{ has_value: false, value: -1 };
}

// =============================================================================
// String Comparison Functions
// =============================================================================

// -----------------------------------------------------------------------------
// str_equals(str* s1, str* s2) -> bool
// -----------------------------------------------------------------------------
// Checks if two strings are equal.
//
// This first compares lengths (O(1)), then compares bytes if lengths match.
//
// Parameters:
//   s1: First string
//   s2: Second string
//
// Returns:
//   true if strings have same length and content, false otherwise
//
// Example:
//   str* a = "hello";
//   str* b = "hello";
//   str* c = "world";
//   str_equals(a, b);  // true
//   str_equals(a, c);  // false
//
// Performance: O(n) worst case, O(1) if lengths differ
// -----------------------------------------------------------------------------
fn str_equals(s1: str*, s2: str*) -> bool {
    int len1 = str_len(s1);
    int len2 = str_len(s2);
    
    // Different lengths means not equal
    if (len1 != len2) {
        return false;
    }
    
    // Compare bytes using memcmp intrinsic
    return __memcmp(s1, s2, len1) == 0;
}

// -----------------------------------------------------------------------------
// str_compare(str* s1, str* s2) -> int
// -----------------------------------------------------------------------------
// Compares two strings lexicographically.
//
// This is useful for sorting strings or implementing ordered data structures.
//
// Parameters:
//   s1: First string
//   s2: Second string
//
// Returns:
//   < 0 if s1 < s2 (s1 comes before s2 alphabetically)
//   = 0 if s1 == s2
//   > 0 if s1 > s2 (s1 comes after s2 alphabetically)
//
// Example:
//   str_compare("apple", "banana");   // < 0
//   str_compare("hello", "hello");    // = 0
//   str_compare("zebra", "apple");    // > 0
// -----------------------------------------------------------------------------
fn str_compare(s1: str*, s2: str*) -> int {
    int len1 = str_len(s1);
    int len2 = str_len(s2);
    int min_len = len1 < len2 ? len1 : len2;
    
    // Compare up to the length of the shorter string
    int result = __memcmp(s1, s2, min_len);
    
    if (result != 0) {
        return result;
    }
    
    // If equal up to min_len, shorter string comes first
    return len1 - len2;
}

// =============================================================================
// String Transformation Functions
// =============================================================================

// -----------------------------------------------------------------------------
// str_to_lower(str* s) -> void
// -----------------------------------------------------------------------------
// Converts ASCII uppercase letters to lowercase in place.
//
// Note: This only handles ASCII (A-Z). For full Unicode case folding,
// use a more comprehensive library.
//
// Parameters:
//   s: String to modify (in place)
//
// Example:
//   str* text = "HELLO";
//   str_to_lower(text);  // text is now "hello"
// -----------------------------------------------------------------------------
fn str_to_lower(s: str*) -> void {
    int len = str_len(s);
    int i = 0;
    
    while (i < len) {
        int c = s[i];
        // Check if uppercase ASCII (A-Z)
        if (c >= 65 && c <= 90) {
            // Convert to lowercase by adding 32
            s[i] = c + 32;
        }
        i = i + 1;
    }
}

// -----------------------------------------------------------------------------
// str_to_upper(str* s) -> void
// -----------------------------------------------------------------------------
// Converts ASCII lowercase letters to uppercase in place.
//
// Note: This only handles ASCII (a-z). For full Unicode case folding,
// use a more comprehensive library.
//
// Parameters:
//   s: String to modify (in place)
//
// Example:
//   str* text = "hello";
//   str_to_upper(text);  // text is now "HELLO"
// -----------------------------------------------------------------------------
fn str_to_upper(s: str*) -> void {
    int len = str_len(s);
    int i = 0;
    
    while (i < len) {
        int c = s[i];
        // Check if lowercase ASCII (a-z)
        if (c >= 97 && c <= 122) {
            // Convert to uppercase by subtracting 32
            s[i] = c - 32;
        }
        i = i + 1;
    }
}

// -----------------------------------------------------------------------------
// str_trim(str* s) -> str*
// -----------------------------------------------------------------------------
// Removes leading and trailing whitespace.
//
// Returns a view into the original string (not a copy).
//
// Whitespace characters: space (32), tab (9), newline (10), carriage return (13)
//
// Parameters:
//   s: String to trim
//
// Returns:
//   Trimmed string view (points into original)
//
// Example:
//   str* text = "  hello  ";
//   str* trimmed = str_trim(text);  // "hello"
// -----------------------------------------------------------------------------
fn str_trim(s: str*) -> str* {
    int len = str_len(s);
    int start = 0;
    int end = len;
    
    // Find first non-whitespace character
    while (start < len) {
        int c = s[start];
        if (c != 32 && c != 9 && c != 10 && c != 13) {
            break;
        }
        start = start + 1;
    }
    
    // Find last non-whitespace character
    while (end > start) {
        int c = s[end - 1];
        if (c != 32 && c != 9 && c != 10 && c != 13) {
            break;
        }
        end = end - 1;
    }
    
    return str_slice(s, start, end);
}

// =============================================================================
// Character Access Functions
// =============================================================================

// -----------------------------------------------------------------------------
// str_char_at(str* s, int index) -> int
// -----------------------------------------------------------------------------
// Gets the byte at a specific index.
//
// Note: This returns a BYTE, not a Unicode character. For proper Unicode
// character access, use str_codepoint_at.
//
// Parameters:
//   s:     String
//   index: Byte index (0-based)
//
// Returns:
//   The byte value at index, or -1 if out of bounds
//
// Example:
//   str* text = "Hello";
//   int c = str_char_at(text, 1);  // c = 101 (ASCII 'e')
// -----------------------------------------------------------------------------
fn str_char_at(s: str*, index: int) -> int {
    int len = str_len(s);
    
    if (index < 0 || index >= len) {
        return -1;
    }
    
    return s[index];
}

// -----------------------------------------------------------------------------
// str_set_char(str* s, int index, int c) -> void
// -----------------------------------------------------------------------------
// Sets the byte at a specific index.
//
// Use with caution - this modifies the string in place and can corrupt
// UTF-8 sequences.
//
// Parameters:
//   s:     String to modify
//   index: Byte index (0-based)
//   c:     New byte value (0-255)
// -----------------------------------------------------------------------------
fn str_set_char(s: str*, index: int, c: int) -> void {
    int len = str_len(s);
    
    if (index >= 0 && index < len) {
        s[index] = c;
    }
}