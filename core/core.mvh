// MIT License
//
// Copyright (c) 2025 ramsy0dev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// file: stdlib/core/core.mvh
// description: Core stdlib header for ManV

// =============================================================================
// Option Type
// =============================================================================

// Option<T> represents an optional value - either Some(T) or None.
// Used for safe return values that may not exist.
struct Option<T> {
    has_value: bool;
    value: T;
}

// =============================================================================
// String Functions
// =============================================================================

// Returns byte length of string (O(1))
fn str_len(s: str*) -> int;

// Returns UTF-8 character count (O(n))
fn str_char_len(s: str*) -> int;

// Returns true if string is empty
fn str_is_empty(s: str*) -> bool;

// Concatenates two strings, returns new heap-allocated string
fn str_concat(s1: str*, s2: str*) -> str*;

// Returns a slice of the string. Panics on invalid bounds.
fn str_slice(s: str*, start: int, end: int) -> str;

// Returns Option<str>. None if bounds are invalid.
fn str_try_slice(s: str*, start: int, end: int) -> Option<str>;

// Returns true if string contains substring
fn str_contains(s: str*, substr: str*) -> bool;

// Returns true if string starts with prefix
fn str_starts_with(s: str*, prefix: str*) -> bool;

// Returns true if string ends with suffix
fn str_ends_with(s: str*, suffix: str*) -> bool;

// Returns Option<int> - index of first occurrence or None
fn str_find(s: str*, substr: str*) -> Option<int>;

// =============================================================================
// Int Functions
// =============================================================================

// Returns absolute value. Panics on INT_MIN.
fn int_abs(x: int) -> int;

// Returns absolute value with wrapping on overflow
fn int_abs_wrapping(x: int) -> int;

// Clamps value to [min, max] range
fn int_clamp(x: int, min_val: int, max_val: int) -> int;

// Returns minimum of two values
fn int_min(a: int, b: int) -> int;

// Returns maximum of two values
fn int_max(a: int, b: int) -> int;

// Raises to power (integer exponent)
fn int_pow(base: int, exp: int) -> int;

// Converts to heap-allocated string
fn int_to_str(x: int) -> str*;

// =============================================================================
// Float Functions
// =============================================================================

// Returns absolute value
fn float_abs(x: float) -> float;

// Rounds down to nearest integer
fn float_floor(x: float) -> float;

// Rounds up to nearest integer
fn float_ceil(x: float) -> float;

// Rounds to nearest integer
fn float_round(x: float) -> float;

// Returns true if NaN
fn float_is_nan(x: float) -> bool;

// Returns true if infinity
fn float_is_inf(x: float) -> bool;

// Returns true if finite (not NaN or infinity)
fn float_is_finite(x: float) -> bool;

// Converts to heap-allocated string
fn float_to_str(x: float) -> str*;

// =============================================================================
// Array Functions
// =============================================================================

// Returns array length (compile-time constant for static arrays)
fn array_len(arr: void*) -> int;

// Safe element access. Returns Option<T>.
fn array_get(arr: void*, index: int) -> Option<T>;

// Unsafe element access. Panics on out of bounds.
fn array_at(arr: void*, index: int) -> T;

// Sets element at index
fn array_set(arr: void*, index: int, value: T) -> void;

// Returns true if array is empty
fn array_is_empty(arr: void*) -> bool;

// =============================================================================
// Bytes Functions
// =============================================================================

// Returns byte count
fn bytes_len(b: bytes*) -> int;

// Safe byte access. Returns Option<int>.
fn bytes_get(b: bytes*, index: int) -> Option<int>;

// Sets byte at index
fn bytes_set(b: bytes*, index: int, value: int) -> void;